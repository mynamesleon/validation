{"version":3,"sources":["validation.js"],"names":["root","factory","define","amd","$","validation","jQuery","this","app","rules","required","validate","val","call","alpha","regex","test","alphanumeric","email","RegExp","join","min","parseFloat","max","range","separators","rangeArr","replace","split","toCheck","match","minlength","element","isCheckable","getByAttribute","filter","length","maxlength","rangelength","minwords","trim","maxwords","rangewords","number","isNaN","isFinite","integer","digits","checked","unchecked","confirm","selector","$current","func","arg","i","a","charAt","chartAt","Error","undefined","substr","e","toStringProto","Object","prototype","toString","reg","date","Date","url","ipaddress","ipv4","ipv6","creditcard","notAllowed","nonDigits","currentDigit","n","numToCheck","bEven","nDigit","parseInt","colour","keywords","hex","hsl","hsla","rgb","rgba","types","thisType","j","expr","attr","inArray","addTest","name","toLowerCase","param","setRules","thisAlias","aliases","ip","color","numeric","format","pattern","regexp","equals","equalto","matches","setErrorClassString","r","hasOwnProperty","push","errorClassString","getFormData","$form","attribute","document","$inputs","find","not","data","each","attrArray","$input","currentDataPoint","indexOf","getValue","elem","$el","$result","result","value","isArray","setClasses","removeClass","triggerHandler","addClass","getRules","stored","arr","$elem","nodeName","all","$holder","$elems","rulesArr","checkRequired","currentRule","funcToCall","splitRule","shift","rulesString","handle","tests","prep","on","closest","prevent","parent","init"],"mappings":";;;;;;;CASC,SAAUA,EAAMC,GACb,YAE2B,mBAAhBD,GAAKE,QAAyBF,EAAKE,OAAOC,IAEjDH,EAAKE,QAAQ,UAAW,SAAUE,GAI9B,MAAQJ,GAAKK,WAAaJ,EAAQG,KAKtCJ,EAAKK,WAAaJ,EAAQD,EAAKM,SAGrCC,KAAM,SAAUH,GACd,YAKA,IAAII,MAMAC,GAOIC,UACIC,SAAU,SAAUC,GAChB,MAAOJ,GAAIG,SAASD,SAASG,KAAKN,KAAMK,KAShDE,OACIC,MAAO,gBACPJ,SAAU,SAAUC,GAChB,MAAOH,GAAMK,MAAMC,MAAMC,KAAKJ,KAStCK,cACIF,MAAO,eACPJ,SAAU,SAAUC,GAChB,MAAOH,GAAMQ,aAAaF,MAAMC,KAAKJ,KAU7CM,OACIH,MAAO,GAAII,SACP,oDACA,uCACA,4DACFC,KAAK,KACPT,SAAU,SAAUC,GAChB,MAAOH,GAAMS,MAAMH,MAAMC,KAAKJ,KAUtCS,KACIV,SAAU,SAAUC,EAAKS,GACrB,MAAOC,YAAWV,IAAQU,WAAWD,KAU7CE,KACIZ,SAAU,SAAUC,EAAKW,GACrB,MAAOD,YAAWV,IAAQU,WAAWC,KAU7CC,OACIC,WAAY,gBACZd,SAAU,SAAUC,EAAKY,GACrB,GAAIE,GAAWF,EAAMG,QAAQlB,EAAMe,MAAMC,WAAY,KAAKG,MAAM,KAC5DC,EAAUP,WAAWV,EAEzB,OAAOiB,IAAWP,WAAWI,EAAS,KAAOG,GAAWP,WAAWI,EAAS,MAUpFI,OACInB,SAAU,SAAUC,EAAKkB,GACrB,MAAOlB,KAAQkB,IAUvBC,WACIpB,SAAU,SAAUC,EAAKS,GACrB,GAAIQ,IAAWrB,EAAIwB,QAAQC,YAAY7B,EAAEG,OACnCC,EAAIwB,QAAQE,eAAe9B,EAAEG,MAAO,QAAQ4B,OAAO,YACnDvB,GAAKwB,MAEX,OAAOP,IAAWP,WAAWD,KAUrCgB,WACI1B,SAAU,SAAUC,EAAKW,GACrB,GAAIM,IAAWrB,EAAIwB,QAAQC,YAAY7B,EAAEG,OACnCC,EAAIwB,QAAQE,eAAe9B,EAAEG,MAAO,QAAQ4B,OAAO,YACnDvB,GAAKwB,MAEX,OAAOP,IAAWP,WAAWC,KAUrCe,aACIb,WAAY,gBACZd,SAAU,SAAUC,EAAKY,GACrB,GAAIE,GAAWF,EAAMG,QAAQlB,EAAM6B,YAAYb,WAAY,KAAKG,MAAM,KAClEC,GAAWrB,EAAIwB,QAAQC,YAAY7B,EAAEG,OACxBC,EAAIwB,QAAQE,eAAe9B,EAAEG,MAAO,QAAQ4B,OAAO,YACnDvB,GAAKwB,MAEtB,OAAOP,IAAWP,WAAWI,EAAS,KAAOG,GAAWP,WAAWI,EAAS,MAUpFa,UACI5B,SAAU,SAAUC,EAAKS,GACrB,MAAOjB,GAAEoC,KAAK5B,GAAKgB,MAAM,OAAOQ,QAAUd,WAAWD,KAU7DoB,UACI9B,SAAU,SAAUC,EAAKW,GACrB,MAAOnB,GAAEoC,KAAK5B,GAAKgB,MAAM,OAAOQ,QAAUd,WAAWC,KAU7DmB,YACIjB,WAAY,WACZd,SAAU,SAAUC,EAAKY,GACrB,GAAIE,GAAWF,EAAMG,QAAQlB,EAAMiC,WAAWjB,WAAY,KAAKG,MAAM,KACjEC,EAAUzB,EAAEoC,KAAK5B,GAAKgB,MAAM,OAAOQ,MAEvC,OAAOP,IAAWP,WAAWI,EAAS,KAAOG,GAAWP,WAAWI,EAAS,MAUpFiB,QACIhC,SAAU,SAAUC,GAChB,OAAQgC,MAAMtB,WAAWV,KAASiC,SAASjC,KASnDkC,SACI/B,MAAO,UACPJ,SAAU,SAAUC,GAChB,MAAOH,GAAMqC,QAAQ/B,MAAMC,KAAKJ,KASxCmC,QACIhC,MAAO,QACPJ,SAAU,SAAUC,GAChB,MAAOH,GAAMsC,OAAOhC,MAAMC,KAAKJ,KAQvCoC,SACIrC,SAAU,SAAUC,GAChB,MAAsB,mBAARA,GAAsBJ,EAAIwB,QAAQE,eAAe9B,EAAEG,MAAO,QAAQ4B,OAAO,YAAYC,OAAS,EAAY,OAARxB,IAQxHqC,WACItC,SAAU,SAAUC,GAChB,MAAsB,mBAARA,GAAgG,IAA1EJ,EAAIwB,QAAQE,eAAe9B,EAAEG,MAAO,QAAQ4B,OAAO,YAAYC,OAAuB,OAARxB,IAa1HsC,SACIvC,SAAU,SAAUC,EAAKuC,GACrB,GACIC,GACAhB,EACAiB,EACAC,EACAC,EALAC,IAQJ,IAAwB,gBAAbL,KACPA,EAAWA,EAASvB,MAAM,YAAYR,KAAK,KAGhB,MAAvB+B,EAASM,OAAO,IAAuD,MAAzCN,EAASM,OAAON,EAASf,OAAS,IAAY,CAK5E,IAJAoB,EAAIpD,EAAEoC,MAAMW,EAAW,KAAKvB,MAAM,MAAMR,KAAK,WAAWO,QAAQ,KAAM,KAAKC,MAAM,WACjFQ,EAASoB,EAAEpB,OAGNmB,EAAI,EAAGA,EAAInB,EAAQmB,GAAK,EAAG,CAK5B,GAJAF,EAAOG,EAAED,GACTD,EAAME,EAAED,EAAI,GAGC,MAATF,EAEAA,EAAOjD,MACJ,IAAwB,MAApBiD,EAAKK,QAAQ,GAEpB,KAAM,IAAIC,OAAM,iDAIpBL,GAAc,SAARA,EAAiB/C,KAAe,UAAR+C,EAAkBM,OAAYN,EAGpC,mBAAbF,IACPC,EAAOA,EAAK1B,QAAQ,IAAK,IACzB2B,EAAqB,mBAARA,GAAsBA,EAAMA,EAAIO,OAAO,EAAGP,EAAIlB,OAAS,GACpEgB,EAAWA,EAASC,GAAMC,IAE1BF,EAAWC,EAAKC,GAIxB,IACI,MAAO1C,KAAQwC,EAASxC,MAC1B,MAAOkD,GACL,KAAM,IAAIH,OAAM,kCAK5B,MAAO/C,KAAQR,EAAE+C,GAAUvC,QAUnCG,OACIgD,cAAeC,OAAOC,UAAUC,SAChCvD,SAAU,SAAUC,EAAKuD,GACrB,MAAmB,gBAARA,GACA,GAAIhD,QAAOgD,EAAIvC,MAAM,YAAYR,KAAK,MAAMJ,KAAKJ,GACT,oBAAxCH,EAAMM,MAAMgD,cAAclD,KAAKsD,GAC/BA,EAAInD,KAAKJ,GADb,SAWfwD,MACIrD,MAAO,cACPJ,SAAU,SAAUC,GAChB,OAAQH,EAAM2D,KAAKrD,MAAMC,KAAK,GAAIqD,MAAKzD,GAAKsD,cAUpDI,KACIvD,MAAO,GAAII,SACP,yBACA,uBACA,MACA,mCACA,gDACA,qDACA,yCACA,6CACA,kDACA,6DACA,iEACA,sCACA,QACA,iBACA,iBACA,KACFC,KAAK,IAAK,KACZT,SAAU,SAAUC,GAChB,MAAOH,GAAM6D,IAAIvD,MAAMC,KAAKJ,KAUpC2D,WACIC,KAAM,GAAIrD,SACN,sDACA,2CACA,gCACA,KACFC,KAAK,KAEPqD,KAAM,GAAItD,SACN,QACA,IACA,gDACA,sIACA,gJACA,sKACA,0KACA,0KACA,0KACA,oJACA,IACA,iDACFC,KAAK,KAEPT,SAAU,SAAUC,GAChB,MAAOH,GAAM8D,UAAUC,KAAKxD,KAAKJ,IAAQH,EAAM8D,UAAUE,KAAKzD,KAAKJ,KAS3E8D,YACIC,WAAY,GAAIxD,QAAO,eACvByD,UAAW,MACXjE,SAAU,SAAUC,GAEhB,GAAIH,EAAMiE,WAAWC,WAAW3D,KAAKJ,GACjC,OAAO,CAGX,IAEIiE,GAEAC,EAJAC,EAAa,EACbC,GAAQ,EAERC,EAAS,CAOb,IAHArE,EAAMA,EAAIe,QAAQlB,EAAMiE,WAAWE,UAAW,IAG1ChE,EAAIwB,OAAS,IAAMxB,EAAIwB,OAAS,GAChC,OAAO,CAGX,KAAK0C,EAAIlE,EAAIwB,OAAS,EAAG0C,GAAK,EAAGA,GAAK,EAClCD,EAAejE,EAAI6C,OAAOqB,GAC1BG,EAASC,SAASL,EAAc,IAC5BG,IACKC,GAAU,GAAK,IAChBA,GAAU,GAGlBF,GAAcE,EACdD,GAASA,CAGb,OAAQD,GAAa,KAAQ,IAYrCI,QACI1D,WAAY,gBAEZ2D,UACI,YAAa,eAAgB,OAAQ,aAAc,QAAS,QAAS,SAAU,QAAS,iBAAkB,OAC1G,aAAc,QAAS,YAAa,YAAa,aAAc,YAAa,QAAS,iBAAkB,WACvG,UAAW,OAAQ,WAAY,WAAY,gBAAiB,WAAY,YAAa,WAAY,YACjG,cAAe,iBAAkB,aAAc,aAAc,UAAW,aAAc,eAAgB,gBACtG,gBAAiB,gBAAiB,gBAAiB,aAAc,WAAY,cAAe,UAAW,UACvG,aAAc,YAAa,cAAe,cAAe,UAAW,YAAa,aAAc,OAAQ,YACvG,OAAQ,QAAS,cAAe,OAAQ,WAAY,UAAW,YAAa,SAAU,QAAS,QAAS,WACxG,gBAAiB,YAAa,eAAgB,YAAa,aAAc,YAAa,uBACtF,YAAa,aAAc,YAAa,YAAa,cAAe,gBAAiB,eAAgB,iBACrG,iBAAkB,iBAAkB,cAAe,OAAQ,YAAa,QAAS,UAAW,SAAU,mBACtG,aAAc,eAAgB,eAAgB,iBAAkB,kBAAmB,oBAAqB,kBACxG,kBAAmB,eAAgB,YAAa,YAAa,WAAY,cAAe,OAAQ,UAAW,QAC3G,YAAa,SAAU,YAAa,SAAU,gBAAiB,YAAa,gBAAiB,gBAAiB,aAC9G,YAAa,OAAQ,OAAQ,OAAQ,aAAc,SAAU,MAAO,YAAa,YAAa,cAAe,SAC7G,aAAc,WAAY,WAAY,SAAU,SAAU,UAAW,YAAa,YAAa,YAAa,OAC5G,cAAe,YAAa,MAAO,OAAQ,UAAW,SAAU,cAAe,YAAa,SAAU,QAAS,QAC/G,aAAc,SAAU,eAG5BrE,OACIsE,KACI,sCAEJC,KACI,0FAEJC,MACI,6FAEJC,KACI,0GACA,6EAEJC,MACI,2FACA,8EAIR9E,SAAU,SAAUC,EAAK8E,GACrB,GAEIC,GACApC,EACAqC,EAJAR,EAAW3E,EAAM0E,OAAOC,SACxBS,EAAOpF,EAAM0E,OAAOpE,KAMxB,IAA6B,UAAzBX,EAAEG,MAAMuF,KAAK,QACb,MAAOD,GAAKR,IAAI,GAAGrE,KAAKJ,EAY5B,IARA8E,EAAQA,IAAU,WAAY,MAAO,MAAO,OAAQ,MAAO,QAGtC,gBAAVA,KACPA,EAAQA,EAAM/D,QAAQlB,EAAM0E,OAAO1D,WAAY,KAAKG,MAAM,MAI1DxB,EAAE2F,QAAQ,WAAYL,IAAS,GAAMtF,EAAE2F,QAAQnF,EAAKwE,IAAY,EAChE,OAAO,CAIX,KAAK7B,EAAI,EAAGA,EAAImC,EAAMtD,OAAQmB,GAAK,EAG/B,GAFAoC,EAAWD,EAAMnC,GAEa,gBAAnBsC,GAAKF,GACZ,IAAKC,EAAI,EAAGA,EAAIC,EAAKF,GAAUvD,OAAQwD,GAAK,EAExC,GAAIC,EAAKF,GAAUC,GAAG5E,KAAKJ,GACvB,OAAO,CAOvB,QAAO,IASfoF,QAAS,SAAUC,EAAMjF,GACrB,GAAoB,gBAATiF,IAAqC,kBAATjF,GACnC,KAAM,IAAI2C,OAAM,qDAIpBsC,GAAOA,EAAKC,cAGe,mBAAhBzF,GAAMwF,KACbxF,EAAMwF,IACFtF,SAAU,SAAUC,EAAKuF,GACrB,MAAOnF,GAAKH,KAAKN,KAAMK,EAAKuF,OAS5CC,SAAU,WACN,GAAI7C,GAEA8C,EACAC,GACI,WAAY,QAAS,eAAgB,QAAS,UAAW,SAAU,UAAW,SAAU,UAAW,UACnG,SAAU,KAAM,YAAa,UAAW,YAAa,OAAQ,MAAO,aAAc,QAAS,SAWnG,KAPA7F,EAAM8F,GAAK9F,EAAM8D,UACjB9D,EAAM+F,MAAQ/F,EAAM0E,OACpB1E,EAAMgG,QAAUhG,EAAMkC,OACtBlC,EAAMiG,OAASjG,EAAMkG,QAAUlG,EAAMmG,OAASnG,EAAMM,MACpDN,EAAMoG,OAASpG,EAAMqG,QAAUrG,EAAMsG,QAAUtG,EAAMqB,MAGhDyB,EAAI,EAAGA,EAAI+C,EAAQlE,OAAQmB,GAAK,EACjC8C,EAAYC,EAAQ/C,GACpB9C,EAAM,KAAO4F,GAAa5F,EAAM4F,IAOxCW,oBAAqB,WACjB,GAAIzD,GACA0D,GAAK,oBAET,KAAK1D,IAAK9C,GACFA,EAAMyG,eAAe3D,IAA0B,gBAAb9C,GAAM8C,IACxC0D,EAAEE,KAAK,qBAAuB5D,EAItC9C,GAAM2G,iBAAmBH,EAAE7F,KAAK,MA+a5C,OAxaAZ,IAQI6G,YAAa,SAAUC,EAAOC,GAE1BD,EAAQA,GAASlH,EAAE,2BACnBmH,EAAYA,GAAa,OAGJ,gBAAVD,IAAuBA,EAAMlF,SACpCkF,EAAQlH,EAAEoH,UAGd,IAAIC,GAAUH,EAAMI,KAAK,2BAA2BC,IAAI,oCACpDC,IA2CJ,OAxCAH,GAAQI,KAAK,WACT,GAGIC,GACA1F,EACAmB,EALAwE,EAAS3H,EAAEG,MACXuF,EAAOiC,EAAOjC,KAAKyB,GACnBS,EAAmBJ,CAMvB,IAAoB,mBAAT9B,GAAX,CAUA,GALIA,EAAKmC,QAAQ,MAAO,GAAMnC,EAAKmC,QAAQ,MAAO,IAC9CnC,EAAOA,EAAKlE,MAAM,KAAKR,KAAK,KAAKQ,MAAM,KAAKR,KAAK,KAIjD0E,EAAKmC,QAAQ,QAAS,EAEtB,YADAL,EAAK9B,GAAQtF,EAAIwB,QAAQkG,SAASH,EAAQR,GAS9C,KAJAO,EAAYhC,EAAKlE,MAAM,KACvBQ,EAAS0F,EAAU1F,OAGdmB,EAAI,EAAGA,EAAInB,EAAS,EAAGmB,GAAK,EACiB,mBAAnCyE,GAAiBF,EAAUvE,MAClCyE,EAAiBF,EAAUvE,QAE/ByE,EAAmBA,EAAiBF,EAAUvE,GAIlDyE,GAAiBF,EAAU1F,EAAS,IAAM5B,EAAIwB,QAAQkG,SAASH,EAAQR,MAGpEK,GAMX5F,SAMIC,YAAa,SAAUkG,GACnB,MAAO,kBAAoBnH,KAAKZ,EAAE+H,GAAMrC,KAAK,UASjD5D,eAAgB,SAAUkG,EAAKb,GAC3BA,EAAYA,GAAa,MACzB,IAAIc,GAAUjI,EAAE,IAAMmH,EAAY,KAAOa,EAAItC,KAAKyB,GAAa,KAC/D,OAAOc,GAAQjG,OAASiG,EAAUD,GAStCF,SAAU,SAAUE,EAAKb,GACrB,GAAIe,KAwBJ,OAvBAf,GAAYA,GAAa,OAGrB/G,EAAIwB,QAAQC,YAAYmG,KACxBA,EAAM5H,EAAIwB,QAAQE,eAAekG,EAAK,QAAQjG,OAAO,aAIzDiG,EAAIP,KAAK,WACL,GAAIU,GAAQnI,EAAEG,MAAMK,KAEhBR,GAAEoI,QAAQD,KACVA,EAAQA,EAAMnH,KAAK,MAEvBkH,EAAOnB,KAAKoB,KAIM,IAAlBD,EAAOlG,QACPkG,EAAOnB,MAAK,GAITmB,EAAOlH,KAAK,MAQvBqH,WAAY,SAAUL,EAAKE,GAEvBF,EAAIM,YAAYjI,EAAM2G,kBAIlBkB,KAAW,EACXF,EAAIO,eAAe,qBAEnBP,EAAIQ,SAAS,uCAAyCN,GAAQK,eAAe,oBAAqBL,IAS1GO,SAAU,SAAUT,GAChB,GAAIE,MACAQ,IAGJ,OAAmB,KAAfV,EAAIhG,OACGgG,EAAIR,KAAK,eAIpBQ,EAAIP,KAAK,WACL,GAEIzF,GACAmB,EAHA9C,EAAQL,EAAEG,MAAMqH,KAAK,cACrBmB,IAKJ,IAAqB,mBAAVtI,GAOX,IAHAsI,EAAMtI,EAAMmB,MAAM,KAClBQ,EAAS2G,EAAI3G,OAERmB,EAAI,EAAGA,EAAInB,EAAQmB,GAAK,EAEK,mBAAnBuF,GAAOC,EAAIxF,MAClB+E,EAAOnB,KAAK4B,EAAIxF,IAEhBuF,EAAOC,EAAIxF,KAAM,KAItB+E,EAAOlH,KAAK,QAQ3BT,UAOID,SAAU,SAAUE,GAChB,GAAIoI,GAAQ5I,EAAEG,KAGd,OAA0B,WAAtByI,EAAM,GAAGC,SACFrI,GAAOA,EAAIwB,OAAS,GAAa,MAARxB,GAAuB,OAARA,EAI/CJ,EAAIwB,QAAQC,YAAY+G,GACjBA,EAAM7G,OAAO,YAAYC,OAAS,EAI1B,gBAARxB,KACEA,EAINA,EAAIwB,OAAS,GAQxB8G,IAAK,SAAUpF,GACX,GAAIqF,GAAU/I,EAAEG,MACZ6I,EAASD,EAAQzB,KAAK,6EAI1B,OAFA0B,GAAOvB,KAAKrH,EAAIG,SAASqB,SAErBoH,EAAOjH,OAAO,sBAAsBC,QACpC+G,EAAQP,SAAS,qBAAqBD,eAAe,oBAAqBnI,EAAI6G,YAAY8B,KACnF,IAGXA,EAAQT,YAAY,qBAAqBC,eAAe,oBAAqBnI,EAAI6G,YAAY8B,KACtF,IAWX1I,MAAO,SAAU2H,EAAKiB,EAAUd,EAAOe,GACnC,GAAqB,mBAAVf,GACP,KAAM,IAAI5E,OAAM,oBAGpB,IAEI4F,GACAC,EACAC,EACAtD,EACA5C,EANAnB,EAASiH,EAASjH,OAClBkG,GAAS,CAQb,KAAK/E,EAAI,EAAGA,EAAInB,EAAQmB,GAAK,EAAG,CAc5B,GAbAgG,EAAcF,EAAS9F,GACvB4C,EAAQvC,OAGJ2F,EAAYtB,QAAQ,MAAO,IAC3BwB,EAAYF,EAAY3H,MAAM,KAC9B2H,EAAcE,EAAUC,QACxBvD,EAAQsD,EAAUrI,KAAK,MAI3BmI,EAAcA,EAAYrD,cAEQ,gBAAvBzF,GAAM8I,GACb,KAAM,IAAI5F,OAAM,gEAAmE4F,EAAc,KAOrG,IAHAC,EAAa/I,EAAM8I,GAAa5I,UAG5B2I,KAAkB,GAA0B,aAAhBC,GAA8C,eAAhBA,IAK1C,KAAhBA,GAA4C,kBAAfC,IACzBA,EAAW3I,KAAKuH,EAAKG,EAAOpC,MAAW,EAAO,CAC9CmC,EAASiB,CACT,QAKZ,MAAOjB,IAQXtG,QAAS,SAAU8B,GACf,GAGI6F,GAHAvB,EAAMhI,EAAEG,MACRgI,EAAQ/H,EAAIwB,QAAQkG,SAASE,GAC7BE,GAAS,CAsBb,OAjBI9H,GAAIwB,QAAQC,YAAYmG,KACxBA,EAAM5H,EAAIwB,QAAQE,eAAekG,EAAK,SAI1CuB,EAAcnJ,EAAIwB,QAAQ6G,SAAST,GAQ/BE,EALC9H,EAAIG,SAASD,SAASG,KAAKuH,EAAKG,GAKxB/H,EAAIG,SAASF,MAAM2H,EAAKuB,EAAY/H,MAAM,KAAM2G,GAAO,IAHtD,IAAMoB,EAAYzD,cAAgB,KAAK+B,QAAQ,eAAgB,EAAK,cAAc,IAAM0B,EAAYzD,cAAgB,KAAK+B,QAAQ,iBAAkB,IAAK,aAMtKzH,EAAIwB,QAAQyG,WAAWL,EAAKE,GACrBA,GAgBXsB,OAAQ,SAAUrB,EAAOsB,EAAOP,GAC5B,GAAIF,EAGJ,OAAqB,gBAAVb,IAAgC,OAAVA,GAER,mBAAVsB,IAAmC,OAAVA,GAA4B,KAAVA,IAClDA,GAAS,aAIQ,gBAAVA,KACPA,EAAQA,EAAMjI,MAAM,MAIjBpB,EAAIG,SAASF,SAAUoJ,EAAOtB,EAAOe,IAAiB,MAGvDF,EAAShJ,EAAEmI,GAAS,4BAA4BnG,SAKtD3B,EAAMuG,sBAGC,yBAA2BhG,KAAKoI,EAAO,GAAGH,WAC1CG,EAAOvB,KAAKrH,EAAIG,SAASqB,SAASG,OAAO,qBAAqBC,OAC/D5B,EAAIG,SAASuI,IAAIrI,KAAKuI,MAQxCU,KAAM,WAEF,GAAIxC,GAAQlH,EAAEG,MAAMuF,KAAK,kBAAmB,MAGtB,UAAlBvF,KAAK0I,UACL3B,EAAMyC,GAAG,SAAU,SAAUjG,GACzB,MAAOtD,GAAIG,SAASiJ,OAAOrJ,QAKnC+G,EAAMyC,GAAG,QAAS,sBAAuB,SAAUjG,GAC/CtD,EAAIG,SAASiJ,OAAOxJ,EAAEG,MAAMyJ,QAAQ,8BAIxC1C,EAAMyC,GAAG,SAAU,0BAA2B,SAAUjG,GAEpD,GAAImG,GAAU3C,EAAM4C,SAASF,QAAQ,2BAA2B5H,SAG3D5B,EAAIwB,QAAQC,YAAY7B,EAAEG,QACpBC,EAAIwB,QAAQE,eAAe9B,EAAEG,MAAO,QAAQ4B,OAAO,qBAAqBC,OACnC,mBAA/BhC,GAAEG,MAAMqH,KAAK,cAEzBqC,IACDzJ,EAAIG,SAASiJ,OAAOrJ,SAQhC4J,KAAM,WACF/J,EAAE,4BAA4ByH,KAAKrH,EAAIsJ,QAK/CrJ,EAAM2F,YAIF+D,KAAM3J,EAAI2J,KACVnE,QAASvF,EAAMuF,QACfqB,YAAa7G,EAAI6G,YACjB1G,SAAU,SAAU4H,EAAO9H,GACvB,MAAOD,GAAIG,SAASiJ,OAAOrB,EAAO9H,GAAO","file":"validation.min.js","sourcesContent":["/*\n * validation\n * Leon Slater\n * http://mynamesleon.com\n * github.com/mynamesleon/validation\n * @license: MIT\n */\n\n/* @namespace validation */\n(function (root, factory) {\n    'use strict';\n\n    if (typeof root.define === 'function' && root.define.amd) {\n        // AMD. Register as an anonymous module.\n        root.define(['jQuery'], function ($) {\n            // Also create a global in case some scripts\n            // that are loaded still are looking for\n            // a global even when an AMD loader is in use.\n            return (root.validation = factory($));\n        });\n\n    } else {\n        // Browser globals\n        root.validation = factory(root.jQuery);\n    }\n\n}(this, function ($) {\n    'use strict';\n\n    // todo: set up unit tests for all validation rules\n    // todo: remove need for continue at any point\n\n    var app = {},\n\n        /*\n         * all validation rules called in element context\n         * should always return a boolean\n         */\n        rules = {\n\n            /*\n             * required rule - the rule in this object is not called internally\n             * @param val {string}\n             * @return {boolean}\n             */\n            required: {\n                validate: function (val) {\n                    return app.validate.required.call(this, val);\n                }\n            },\n\n            /*\n             * letters only\n             * @param val {string}\n             * @return {boolean}\n             */\n            alpha: {\n                regex: /^[a-zA-Z\\s]+$/,\n                validate: function (val) {\n                    return rules.alpha.regex.test(val);\n                }\n            },\n\n            /*\n             * letters and numbers only\n             * @param val {string}\n             * @return {boolean}\n             */\n            alphanumeric: {\n                regex: /^[a-z0-9]+$/i,\n                validate: function (val) {\n                    return rules.alphanumeric.regex.test(val);\n                }\n            },\n\n            /*\n             * email test - allows formats as simple as name@domain\n             * https://html.spec.whatwg.org/multipage/forms.html#valid-e-mail-address\n             * @param val {string}\n             * @return {boolean}\n             */\n            email: {\n                regex: new RegExp([\n                    '^[a-zA-Z0-9.!#$%&\\'*+\\/=?\\\\^_`{|}~\\\\-]+@[a-zA-Z0-9]',\n                    '(?:[a-zA-Z0-9\\\\-]{0,61}[a-zA-Z0-9])?',\n                    '(?:\\\\.[a-zA-Z0-9](?:[a-zA-Z0-9\\\\-]{0,61}[a-zA-Z0-9])?)*$'\n                ].join('')),\n                validate: function (val) {\n                    return rules.email.regex.test(val);\n                }\n            },\n\n            /*\n             * minimum number\n             * @param val {string}\n             * @param min {string|number}\n             * @return {boolean}\n             */\n            min: {\n                validate: function (val, min) {\n                    return parseFloat(val) >= parseFloat(min);\n                }\n            },\n\n            /*\n             * maximum number\n             * @param val {string}\n             * @param max {string|number}\n             * @return {boolean}\n             */\n            max: {\n                validate: function (val, max) {\n                    return parseFloat(val) <= parseFloat(max);\n                }\n            },\n\n            /*\n             * range between numbers\n             * @param val {string}\n             * @param range {string}: space (if not in data attribute), comma, hyphen, underscore, pipe or colon delimited\n             * @return {boolean}\n             */\n            range: {\n                separators: /[\\,\\-\\_\\|\\:]/g,\n                validate: function (val, range) {\n                    var rangeArr = range.replace(rules.range.separators, ' ').split(' '),\n                        toCheck = parseFloat(val);\n\n                    return toCheck >= parseFloat(rangeArr[0]) && toCheck <= parseFloat(rangeArr[1]);\n                }\n            },\n\n            /*\n             * match a specific value\n             * @param val {string}\n             * @param match {string}\n             * @return {boolean}\n             */\n            match: {\n                validate: function (val, match) {\n                    return val === match;\n                }\n            },\n\n            /*\n             * minlength of a string, or minimum number of checked inputs\n             * @param val {string}\n             * @param min {string|number}\n             * @return {boolean}\n             */\n            minlength: {\n                validate: function (val, min) {\n                    var toCheck = (app.element.isCheckable($(this))\n                        ? app.element.getByAttribute($(this), 'name').filter(':checked')\n                        : val).length;\n\n                    return toCheck >= parseFloat(min);\n                }\n            },\n\n            /*\n             * maxlength of a string, or maximum number of checked inputs\n             * @param val {string}\n             * @param max {string|number}\n             * @return {boolean}\n             */\n            maxlength: {\n                validate: function (val, max) {\n                    var toCheck = (app.element.isCheckable($(this))\n                        ? app.element.getByAttribute($(this), 'name').filter(':checked')\n                        : val).length;\n\n                    return toCheck <= parseFloat(max);\n                }\n            },\n\n            /*\n             * range between character length\n             * @param val {string}\n             * @param range {string}: space (if not in data attribute), comma, hyphen, underscore, pipe or colon delimited\n             * @return {boolean}\n             */\n            rangelength: {\n                separators: /[\\,\\-\\_\\|\\:]/g,\n                validate: function (val, range) {\n                    var rangeArr = range.replace(rules.rangelength.separators, ' ').split(' '),\n                        toCheck = (app.element.isCheckable($(this))\n                                   ? app.element.getByAttribute($(this), 'name').filter(':checked')\n                                   : val).length;\n\n                    return toCheck >= parseFloat(rangeArr[0]) && toCheck <= parseFloat(rangeArr[1]);\n                }\n            },\n\n            /*\n             * word count minimum\n             * @param val {string}\n             * @param min {string}\n             * @return {boolean}\n             */\n            minwords: {\n                validate: function (val, min) {\n                    return $.trim(val).split(/\\s+/).length >= parseFloat(min);\n                }\n            },\n\n            /*\n             * word count maximum\n             * @param val {string}\n             * @param min {string}\n             * @return {boolean}\n             */\n            maxwords: {\n                validate: function (val, max) {\n                    return $.trim(val).split(/\\s+/).length <= parseFloat(max);\n                }\n            },\n\n            /*\n             * word count range\n             * @param val {string}\n             * @param range {string}: space (if not in data attribute), comma, hyphen, underscore, pipe or colon delimited\n             * @return {boolean}\n             */\n            rangewords: {\n                separators: /[,-_|:]/g,\n                validate: function (val, range) {\n                    var rangeArr = range.replace(rules.rangewords.separators, ' ').split(' '),\n                        toCheck = $.trim(val).split(/\\s+/).length;\n\n                    return toCheck >= parseFloat(rangeArr[0]) && toCheck <= parseFloat(rangeArr[1]);\n                }\n            },\n\n            /*\n             * number only - allows decimals\n             * http://stackoverflow.com/questions/18082/validate-decimal-numbers-in-javascript-isnumeric#1830844\n             * @param val {string}\n             * @return {boolean}\n             */\n            number: {\n                validate: function (val) {\n                    return !isNaN(parseFloat(val)) && isFinite(val);\n                }\n            },\n\n            /*\n             * integer only (allows negatives)\n             * @param val {string}\n             * @return {boolean}\n             */\n            integer: {\n                regex: /^-?\\d+$/,\n                validate: function (val) {\n                    return rules.integer.regex.test(val);\n                }\n            },\n\n            /*\n             * digits only\n             * @param val {string}\n             * @return {boolean}\n             */\n            digits: {\n                regex: /^\\d+$/,\n                validate: function (val) {\n                    return rules.digits.regex.test(val);\n                }\n            },\n\n            /*\n             * must be checked\n             * @return {boolean}\n             */\n            checked: {\n                validate: function (val) {\n                    return typeof val === 'undefined' ? app.element.getByAttribute($(this), 'name').filter(':checked').length > 0 : val !== '-1';\n                }\n            },\n\n            /*\n             * must be unchecked\n             * @return {boolean}\n             */\n            unchecked: {\n                validate: function (val) {\n                    return typeof val === 'undefined' ? app.element.getByAttribute($(this), 'name').filter(':checked').length === 0 : val === '-1';\n                }\n            },\n\n            /*\n             * test value against the value of another input - must use {!space} for spaces needed in the selector\n             * @param val {string}\n             * @param selector {string|jQuery object}: if string, can include basic jQuery methods\n             *      e.g. \"$(this).parent().prev().find('input[type=\\\"text\\\"]')\"\n             *      deliberately restricted so that each jQuery method used can only take one string paramater\n             *      specific handling is included to handle the 'this' keyword when included on data-validation attribute\n             * @return {boolean}\n             */\n            confirm: {\n                validate: function (val, selector) {\n                    var a = [],\n                        $current,\n                        length,\n                        func,\n                        arg,\n                        i;\n\n                    // reminder: spaces in the selector must be replaced with {!space}\n                    if (typeof selector === 'string') {\n                        selector = selector.split('{!space}').join(' ');\n\n                        // if it starts with a $, and ends with ')', assume full jquery selector has been provided\n                        if (selector.charAt(0) === '$' && selector.charAt(selector.length - 1) === ')') {\n                            a = $.trim((selector + ' ').split('()').join('(empty)').replace(') ', '')).split(/[\\)\\(]/g);\n                            length = a.length;\n\n                            // things get messy now...\n                            for (i = 0; i < length; i += 2) {\n                                func = a[i];\n                                arg = a[i + 1];\n\n                                // handle the function to be used\n                                if (func === '$') {\n                                    // set to be jQuery to handle starting case\n                                    func = $;\n                                } else if (func.chartAt(0) !== '.') {\n                                    // if not starting case, make sure the var starts with a '.' to indicate a jQuery method\n                                    throw new Error('Incorrectly formatted jQuery selector function');\n                                }\n\n                                // if given 'this', use $current context; if given empty, set to undefined, otherwise use as is\n                                arg = arg === 'this' ? this : arg === 'empty' ? undefined : arg;\n\n                                // if no $current set, use main jQuery function\n                                if (typeof $current !== 'undefined') {\n                                    func = func.replace('.', '');\n                                    arg = typeof arg === 'undefined' ? arg : arg.substr(1, arg.length - 2);\n                                    $current = $current[func](arg);\n                                } else {\n                                    $current = func(arg);\n                                }\n                            }\n\n                            try {\n                                return val === $current.val();\n                            } catch (e) {\n                                throw new Error('Failed to parse your selector');\n                            }\n                        }\n                    }\n\n                    return val === $(selector).val();\n                }\n            },\n\n            /*\n             * custom regular expression check - must use {!space} for spaces needed in regex\n             * @param val {string}\n             * @param reg {string|object}: will be a string when included in the validation data attribute\n             * @return {boolean}\n             */\n            regex: {\n                toStringProto: Object.prototype.toString,\n                validate: function (val, reg) {\n                    if (typeof reg === 'string') {\n                        return new RegExp(reg.split('{!space}').join(' ')).test(val);\n                    } else if (rules.regex.toStringProto.call(reg) === '[object RegExp]') {\n                        return reg.test(val);\n                    }\n                }\n            },\n\n            /*\n             * date test\n             * @param val {string}\n             * @return {boolean}\n             */\n            date: {\n                regex: /Invalid|NaN/,\n                validate: function (val) {\n                    return !rules.date.regex.test(new Date(val).toString());\n                }\n            },\n\n            /*\n             * url test\n             * https://gist.github.com/dperini/729294\n             * @param val {string}\n             * @return {boolean}\n             */\n            url: {\n                regex: new RegExp([\n                    '^(?:(?:https?|ftp)://)',\n                    '(?:\\\\S+(?::\\\\S*)?@)?',\n                    '(?:',\n                    '(?!(?:10|127)(?:\\\\.\\\\d{1,3}){3})',\n                    '(?!(?:169\\\\.254|192\\\\.168)(?:\\\\.\\\\d{1,3}){2})',\n                    '(?!172\\\\.(?:1[6-9]|2\\\\d|3[0-1])(?:\\\\.\\\\d{1,3}){2})',\n                    '(?:[1-9]\\\\d?|1\\\\d\\\\d|2[01]\\\\d|22[0-3])',\n                    '(?:\\\\.(?:1?\\\\d{1,2}|2[0-4]\\\\d|25[0-5])){2}',\n                    '(?:\\\\.(?:[1-9]\\\\d?|1\\\\d\\\\d|2[0-4]\\\\d|25[0-4]))|',\n                    '(?:(?:[a-z\\\\u00a1-\\\\uffff0-9]-*)*[a-z\\\\u00a1-\\\\uffff0-9]+)',\n                    '(?:\\\\.(?:[a-z\\\\u00a1-\\\\uffff0-9]-*)*[a-z\\\\u00a1-\\\\uffff0-9]+)*',\n                    '(?:\\\\.(?:[a-z\\\\u00a1-\\\\uffff]{2,}))',\n                    '\\\\.?)',\n                    '(?::\\\\d{2,5})?',\n                    '(?:[/?#]\\\\S*)?',\n                    '$'\n                ].join(''), 'i'),\n                validate: function (val) {\n                    return rules.url.regex.test(val);\n                }\n            },\n\n            /*\n             * ipv4 test - allows leading zeros\n             * expressions derived from regular expressions cookbook second edition (august 2012)\n             * @param val {string}\n             * @return {boolean}\n             */\n            ipaddress: {\n                ipv4: new RegExp([\n                    '^(?:(?:25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)\\\\.){3}',\n                    '(?:25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)',\n                    '(\\/([0-9]|[1-2][0-9]|3[0-2]))?', // allow cidr notation\n                    '$'\n                ].join('')),\n\n                ipv6: new RegExp([\n                    '^\\\\s*',\n                    '(',\n                    '(([0-9A-Fa-f]{1,4}:){7}([0-9A-Fa-f]{1,4}|:))|',\n                    '(([0-9A-Fa-f]{1,4}:){6}(:[0-9A-Fa-f]{1,4}|((25[0-5]|2[0-4]\\\\d|1\\\\d\\\\d|[1-9]?\\\\d)(\\\\.(25[0-5]|2[0-4]\\\\d|1\\\\d\\\\d|[1-9]?\\\\d)){3})|:))|',\n                    '(([0-9A-Fa-f]{1,4}:){5}(((:[0-9A-Fa-f]{1,4}){1,2})|:((25[0-5]|2[0-4]\\\\d|1\\\\d\\\\d|[1-9]?\\\\d)(\\\\.(25[0-5]|2[0-4]\\\\d|1\\\\d\\\\d|[1-9]?\\\\d)){3})|:))|',\n                    '(([0-9A-Fa-f]{1,4}:){4}(((:[0-9A-Fa-f]{1,4}){1,3})|((:[0-9A-Fa-f]{1,4})?:((25[0-5]|2[0-4]\\\\d|1\\\\d\\\\d|[1-9]?\\\\d)(\\\\.(25[0-5]|2[0-4]\\\\d|1\\\\d\\\\d|[1-9]?\\\\d)){3}))|:))|',\n                    '(([0-9A-Fa-f]{1,4}:){3}(((:[0-9A-Fa-f]{1,4}){1,4})|((:[0-9A-Fa-f]{1,4}){0,2}:((25[0-5]|2[0-4]\\\\d|1\\\\d\\\\d|[1-9]?\\\\d)(\\\\.(25[0-5]|2[0-4]\\\\d|1\\\\d\\\\d|[1-9]?\\\\d)){3}))|:))|',\n                    '(([0-9A-Fa-f]{1,4}:){2}(((:[0-9A-Fa-f]{1,4}){1,5})|((:[0-9A-Fa-f]{1,4}){0,3}:((25[0-5]|2[0-4]\\\\d|1\\\\d\\\\d|[1-9]?\\\\d)(\\\\.(25[0-5]|2[0-4]\\\\d|1\\\\d\\\\d|[1-9]?\\\\d)){3}))|:))|',\n                    '(([0-9A-Fa-f]{1,4}:){1}(((:[0-9A-Fa-f]{1,4}){1,6})|((:[0-9A-Fa-f]{1,4}){0,4}:((25[0-5]|2[0-4]\\\\d|1\\\\d\\\\d|[1-9]?\\\\d)(\\\\.(25[0-5]|2[0-4]\\\\d|1\\\\d\\\\d|[1-9]?\\\\d)){3}))|:))|',\n                    '(:(((:[0-9A-Fa-f]{1,4}){1,7})|((:[0-9A-Fa-f]{1,4}){0,5}:((25[0-5]|2[0-4]\\\\d|1\\\\d\\\\d|[1-9]?\\\\d)(\\\\.(25[0-5]|2[0-4]\\\\d|1\\\\d\\\\d|[1-9]?\\\\d)){3}))|:))',\n                    ')',\n                    '(%.+)?\\\\s*(\\/(\\\\d|\\\\d\\\\d|1[0-1]\\\\d|12[0-8]))?$' // allow cidr notation\n                ].join('')),\n\n                validate: function (val) {\n                    return rules.ipaddress.ipv4.test(val) || rules.ipaddress.ipv6.test(val);\n                }\n            },\n\n            /*\n             * credit card check\n             * @param val {string}\n             * @return {boolean}\n             */\n            creditcard: {\n                notAllowed: new RegExp('[^0-9 \\\\-]+'),\n                nonDigits: /\\D/g,\n                validate: function (val) {\n                    // accept spaces, digits and dashes only\n                    if (rules.creditcard.notAllowed.test(val)) {\n                        return false;\n                    }\n\n                    var numToCheck = 0,\n                        bEven = false,\n                        currentDigit,\n                        nDigit = 0,\n                        n;\n\n                    // remove anything that is not a digit\n                    val = val.replace(rules.creditcard.nonDigits, '');\n\n                    // estimated min and max length to allow\n                    if (val.length < 13 || val.length > 19) {\n                        return false;\n                    }\n\n                    for (n = val.length - 1; n >= 0; n -= 1) {\n                        currentDigit = val.charAt(n);\n                        nDigit = parseInt(currentDigit, 10);\n                        if (bEven) {\n                            if ((nDigit *= 2) > 9) {\n                                nDigit -= 9;\n                            }\n                        }\n                        numToCheck += nDigit;\n                        bEven = !bEven;\n                    }\n\n                    return (numToCheck % 10) === 0;\n                }\n            },\n\n            /*\n             * colour validation\n             * @param val {string}\n             * @param types {string|array} optional: string or array of colour types\n             *      allowed colour types: keywords, hex, hsl, hsla, rgb, rgba - defaults to all\n             *      can be comma, space, hyphen, underscore, pipe, or colon delimited as a string\n             *      cannot be space delimited when used in data-validation attribute\n             */\n            colour: {\n                separators: /[\\,\\-\\_\\|\\:]/g,\n\n                keywords: [\n                    'aliceblue', 'antiquewhite', 'aqua', 'aquamarine', 'azure', 'beige', 'bisque', 'black', 'blanchedalmond', 'blue',\n                    'blueviolet', 'brown', 'burlywood', 'cadetblue', 'chartreuse', 'chocolate', 'coral', 'cornflowerblue', 'cornsilk',\n                    'crimson', 'cyan', 'darkblue', 'darkcyan', 'darkgoldenrod', 'darkgray', 'darkgreen', 'darkgrey', 'darkkhaki',\n                    'darkmagenta', 'darkolivegreen', 'darkorange', 'darkorchid', 'darkred', 'darksalmon', 'darkseagreen', 'darkslateblue',\n                    'darkslategray', 'darkslategrey', 'darkturquoise', 'darkviolet', 'deeppink', 'deepskyblue', 'dimgray', 'dimgrey',\n                    'dodgerblue', 'firebrick', 'floralwhite', 'forestgreen', 'fuchsia', 'gainsboro', 'ghostwhite', 'gold', 'goldenrod',\n                    'gray', 'green', 'greenyellow', 'grey', 'honeydew', 'hotpink', 'indianred', 'indigo', 'ivory', 'khaki', 'lavender',\n                    'lavenderblush', 'lawngreen', 'lemonchiffon', 'lightblue', 'lightcoral', 'lightcyan', 'lightgoldenrodyellow',\n                    'lightgray', 'lightgreen', 'lightgrey', 'lightpink', 'lightsalmon', 'lightseagreen', 'lightskyblue', 'lightslategray',\n                    'lightslategrey', 'lightsteelblue', 'lightyellow', 'lime', 'limegreen', 'linen', 'magenta', 'maroon', 'mediumaquamarine',\n                    'mediumblue', 'mediumorchid', 'mediumpurple', 'mediumseagreen', 'mediumslateblue', 'mediumspringgreen', 'mediumturquoise',\n                    'mediumvioletred', 'midnightblue', 'mintcream', 'mistyrose', 'moccasin', 'navajowhite', 'navy', 'oldlace', 'olive',\n                    'olivedrab', 'orange', 'orangered', 'orchid', 'palegoldenrod', 'palegreen', 'paleturquoise', 'palevioletred', 'papayawhip',\n                    'peachpuff', 'peru', 'pink', 'plum', 'powderblue', 'purple', 'red', 'rosybrown', 'royalblue', 'saddlebrown', 'salmon',\n                    'sandybrown', 'seagreen', 'seashell', 'sienna', 'silver', 'skyblue', 'slateblue', 'slategray', 'slategrey', 'snow',\n                    'springgreen', 'steelblue', 'tan', 'teal', 'thistle', 'tomato', 'transparent', 'turquoise', 'violet', 'wheat', 'white',\n                    'whitesmoke', 'yellow', 'yellowgreen'\n                ],\n\n                regex: {\n                    hex: [\n                        /(^#[0-9A-F]{6}$)|(^#[0-9A-F]{3}$)/i\n                    ],\n                    hsl: [\n                        /^hsl\\((\\s*(-?\\d+)\\s*,)(\\s*(\\b(0?\\d{1,2}|100)\\b%)\\s*,)(\\s*(\\b(0?\\d{1,2}|100)\\b%)\\s*)\\)$/\n                    ],\n                    hsla: [\n                        /^hsla\\((\\s*(-?\\d+)\\s*,)(\\s*(\\b(0?\\d{1,2}|100)\\b%)\\s*,){2}(\\s*(0?(\\.\\d+)?|1(\\.0+)?)\\s*)\\)$/\n                    ],\n                    rgb: [\n                        /^rgb\\((\\s*(\\b([01]?\\d{1,2}|2[0-4]\\d|25[0-5])\\b)\\s*,){2}(\\s*(\\b([01]?\\d{1,2}|2[0-4]\\d|25[0-5])\\b)\\s*)\\)$/,\n                        /^rgb\\((\\s*(\\b(0?\\d{1,2}|100)\\b%)\\s*,){2}(\\s*(\\b(0?\\d{1,2}|100)\\b%)\\s*)\\)$/\n                    ],\n                    rgba: [\n                        /^rgba\\((\\s*(\\b([01]?\\d{1,2}|2[0-4]\\d|25[0-5])\\b)\\s*,){3}(\\s*(0?(\\.\\d+)?|1(\\.0+)?)\\s*)\\)$/,\n                        /^rgba\\((\\s*(\\b(0?\\d{1,2}|100)\\b%)\\s*,){3}(\\s*(0?(\\.\\d+)?|1(\\.0+)?)\\s*)\\)$/\n                    ]\n                },\n\n                validate: function (val, types) {\n                    var keywords = rules.colour.keywords,\n                        expr = rules.colour.regex,\n                        thisType,\n                        i,\n                        j;\n\n                    // if using a colour input, test against the hex regex straight away\n                    if ($(this).attr('type') === 'color') {\n                        return expr.hex[0].test(val);\n                    }\n\n                    // default to allow all types\n                    types = types || ['keywords', 'hex', 'hsl', 'hsla', 'rgb', 'rgba'];\n\n                    // if types passed in as a string, replace the possible separators and make array\n                    if (typeof types === 'string') {\n                        types = types.replace(rules.colour.separators, ' ').split(' ');\n                    }\n\n                    // keywords check\n                    if ($.inArray('keywords', types) > -1 && $.inArray(val, keywords) > -1) {\n                        return true;\n                    }\n\n                    // cycle through types\n                    for (i = 0; i < types.length; i += 1) {\n                        thisType = types[i];\n                        // if we have expressions for that type, check them\n                        if (typeof expr[thisType] === 'object') {\n                            for (j = 0; j < expr[thisType].length; j += 1) {\n                                // if it passes, return true immediately\n                                if (expr[thisType][j].test(val)) {\n                                    return true;\n                                }\n                            }\n                        }\n                    }\n\n                    // return false by default\n                    return false;\n                }\n            },\n\n            /*\n             * add a test to the internal rules\n             * @param name {string}\n             * @param test {function}\n             */\n            addTest: function (name, test) {\n                if (typeof name !== 'string' || typeof test !== 'function') {\n                    throw new Error('A string and a function are required to add a test');\n                }\n\n                // only store rules as lowercase for consistency, and to protect methods\n                name = name.toLowerCase();\n\n                // do not override any existing rules\n                if (typeof rules[name] === 'undefined') {\n                    rules[name] = {\n                        validate: function (val, param) {\n                            return test.call(this, val, param);\n                        }\n                    };\n                }\n            },\n\n            /*\n             * set rule aliases and add rules to application object to be exposed\n             */\n            setRules: function () {\n                var i,\n                    j,\n                    thisAlias,\n                    aliases = [\n                        'required', 'alpha', 'alphanumeric', 'email', 'equalto', 'format', 'pattern', 'number', 'numeric', 'integer',\n                        'digits', 'ip', 'ipaddress', 'checked', 'unchecked', 'date', 'url', 'creditcard', 'color', 'colour'\n                    ];\n\n                // set specific aliases\n                rules.ip = rules.ipaddress;\n                rules.color = rules.colour;\n                rules.numeric = rules.number;\n                rules.format = rules.pattern = rules.regexp = rules.regex;\n                rules.equals = rules.equalto = rules.matches = rules.match;\n\n                // create is- aliases\n                for (i = 0; i < aliases.length; i += 1) {\n                    thisAlias = aliases[i];\n                    rules['is' + thisAlias] = rules[thisAlias];\n                }\n            },\n\n            /*\n             * generate a space delimited string of all rules\n             */\n            setErrorClassString: function () {\n                var i,\n                    r = ['validation-failed'];\n\n                for (i in rules) {\n                    if (rules.hasOwnProperty(i) && typeof rules[i] === 'object') {\n                        r.push('validation-failed-' + i);\n                    }\n                }\n\n                rules.errorClassString = r.join(' ');\n            }\n        };\n\n    /*\n     * main application methods\n     */\n    app = {\n\n        /*\n         * get data from all inputs in the form\n         * @param $form {jQuery object}\n         * @param attribute {string} optional: attribute to use - defaults to name\n         * @return {object}\n         */\n        getFormData: function ($form, attribute) {\n            // handle defaults\n            $form = $form || $('[data-validation=\"set\"]');\n            attribute = attribute || 'name';\n\n            // default to finding all inouts on the page if no validation has been set\n            if (typeof $form !== 'object' || !$form.length) {\n                $form = $(document);\n            }\n\n            var $inputs = $form.find('input, select, textarea').not('[type=\"submit\"], [type=\"button\"]'),\n                data = {};\n\n            // update data object with input value\n            $inputs.each(function () {\n                var $input = $(this),\n                    attr = $input.attr(attribute),\n                    currentDataPoint = data,\n                    attrArray,\n                    length,\n                    i;\n\n                // do not proceed if attribute does not exist for that element\n                if (typeof attr === 'undefined') {\n                    return;\n                }\n\n                // handle key style naming e.g. primary[secondary][tertiary]\n                if (attr.indexOf('[') > -1 && attr.indexOf(']') > -1) {\n                    attr = attr.split('[').join('.').split(']').join('');\n                }\n\n                // standard case\n                if (attr.indexOf('.') === -1) {\n                    data[attr] = app.element.getValue($input, attribute);\n                    return;\n                }\n\n                // set needed vars for recursive entry creation for chosen attribute\n                attrArray = attr.split('.');\n                length = attrArray.length;\n\n                // set the level in the object that we want to add the new property\n                for (i = 0; i < length - 1; i += 1) {\n                    if (typeof currentDataPoint[attrArray[i]] === 'undefined') {\n                        currentDataPoint[attrArray[i]] = {};\n                    }\n                    currentDataPoint = currentDataPoint[attrArray[i]];\n                }\n\n                // use length - 1 so the final entry in the array is used as the property name\n                currentDataPoint[attrArray[length - 1]] = app.element.getValue($input, attribute);\n            });\n\n            return data;\n        },\n\n        /*\n         * element handling\n         */\n        element: {\n\n            /*\n             * check if element is checkbox or radio type\n             * @param elem {HTMLElement|jQuery object}\n             */\n            isCheckable: function (elem) {\n                return (/radio|checkbox/i).test($(elem).attr('type'));\n            },\n\n            /*\n             * get all elements with matching attribute value\n             * @param $el {jQuery object}\n             * @param attribute {string} optional: defaults to 'name'\n             * @return {jQuery object}: returns $el if none were founding with matching attribute value\n             */\n            getByAttribute: function ($el, attribute) {\n                attribute = attribute || 'name';\n                var $result = $('[' + attribute + '=\"' + $el.attr(attribute) + '\"]');\n                return $result.length ? $result : $el;\n            },\n\n            /*\n             * get element value\n             * @param $el {jQuery object}\n             * @param attribute {string} optional: attribute to use when selecting multiple elements\n             * @return {string}\n             */\n            getValue: function ($el, attribute) {\n                var result = [];\n                attribute = attribute || 'name';\n\n                // get by name for radio or input types\n                if (app.element.isCheckable($el)) {\n                    $el = app.element.getByAttribute($el, 'name').filter(':checked');\n                }\n\n                // cycle through elements to handle elements with the same name\n                $el.each(function () {\n                    var value = $(this).val();\n                    // check for array e.g. multi-select\n                    if ($.isArray(value)) {\n                        value = value.join(',');\n                    }\n                    result.push(value);\n                });\n\n                // if nothing has been added to the result, set to -1 by default\n                if (result.length === 0) {\n                    result.push(-1);\n                }\n\n                // always return a string - join group values with commas\n                return result.join(',');\n            },\n\n            /*\n             * toggle element classes based on validation, and trigger custom events\n             * @param $el {jQuery object}\n             * @param result {boolean|string}: true if validation has passed, otherwise string indicating failed rule\n             */\n            setClasses: function ($el, result) {\n                // remove all rule classes e.g. failed-number\n                $el.removeClass(rules.errorClassString);\n\n                // toggle remaining needed classes and trigger validation event\n                // use triggerHandler to prevent event bubbling\n                if (result === true) {\n                    $el.triggerHandler('validation.passed');\n                } else {\n                    $el.addClass('validation-failed validation-failed-' + result).triggerHandler('validation.failed', result);\n                }\n            },\n\n            /*\n             * build space delimitted rules string\n             * @param $el {jQuery object}: elements to use when getting validation rules\n             * @return {string}\n             */\n            getRules: function ($el) {\n                var result = [],\n                    stored = {};\n\n                // if only one element, return the validation data from it\n                if ($el.length === 1) {\n                    return $el.data('validation');\n                }\n\n                // if multiple, cycle and add\n                $el.each(function () {\n                    var rules = $(this).data('validation'),\n                        arr = [],\n                        length,\n                        i;\n\n                    // continue if no validation rules are specified on the element\n                    if (typeof rules === 'undefined') {\n                        return;\n                    }\n\n                    arr = rules.split(' ');\n                    length = arr.length;\n\n                    for (i = 0; i < length; i += 1) {\n                        // check that the validation rule has not been added already\n                        if (typeof stored[arr[i]] === 'undefined') {\n                            result.push(arr[i]);\n                            // update stored object to indicate that this rule has been added\n                            stored[arr[i]] = true;\n                        }\n                    }\n                });\n                return result.join(' ');\n            }\n\n        },\n\n        /*\n         * validate storage\n         */\n        validate: {\n\n            /*\n             * required rule stored here to prevent being overidden - called in element context\n             * @param val {string}\n             * @return {boolean}\n             */\n            required: function (val) {\n                var $elem = $(this);\n\n                // handle select - check that a value exists, is not empty, and is not 0 or -1\n                if ($elem[0].nodeName === 'SELECT') {\n                    return val && val.length > 0 && val !== '0' && val !== '-1';\n                }\n\n                // handle radio and checkbox\n                if (app.element.isCheckable($elem)) {\n                    return $elem.filter(':checked').length > 0;\n                }\n\n                // handle any non string values\n                if (typeof val !== 'string') {\n                    return !!val;\n                }\n\n                // default\n                return val.length > 0;\n            },\n\n            /*\n             * trigger validation on whole form - validates all set form elements\n             * @param e {object}: event object\n             * @return {boolean}: if validation has passed\n             */\n            all: function (e) {\n                var $holder = $(this),\n                    $elems = $holder.find('input[data-validation], select[data-validation], textarea[data-validation]');\n\n                $elems.each(app.validate.element);\n\n                if ($elems.filter('.validation-failed').length) {\n                    $holder.addClass('validation-failed').triggerHandler('validation.failed', app.getFormData($holder));\n                    return false; // return value, and prevents default action if event object is passed in\n                }\n\n                $holder.removeClass('validation-failed').triggerHandler('validation.passed', app.getFormData($holder));\n                return true;\n            },\n\n            /*\n             * cycle through all rules for an element\n             * @param $el {jQuery object}\n             * @param rulesArr {array}: array of rule strings\n             * @aram value {string}: element value\n             * @param checkRequired {boolean}: defaults to false\n             * @return {boolean|string}: a string containing the failed rule, or true if validation passed\n             */\n            rules: function ($el, rulesArr, value, checkRequired) {\n                if (typeof value === 'undefined') {\n                    throw new Error('No value provided');\n                }\n\n                var length = rulesArr.length,\n                    result = true,\n                    currentRule,\n                    funcToCall,\n                    splitRule,\n                    param,\n                    i;\n\n                // cycle through remaining rules\n                for (i = 0; i < length; i += 1) {\n                    currentRule = rulesArr[i];\n                    param = undefined;\n\n                    // extract any provided param - use shift and join to handle multiple colons in value\n                    if (currentRule.indexOf(':') > -1) {\n                        splitRule = currentRule.split(':');\n                        currentRule = splitRule.shift();\n                        param = splitRule.join(':');\n                    }\n\n                    // all validation rules are stored as lower case\n                    currentRule = currentRule.toLowerCase();\n\n                    if (typeof rules[currentRule] !== 'object') {\n                        throw new Error('That validation test does not exist. Use validation.addTest(\\'' + currentRule + '\\')');\n                    }\n\n                    // grab rule validate method\n                    funcToCall = rules[currentRule].validate;\n\n                    // whether to run required checks\n                    if (checkRequired === false && (currentRule === 'required' || currentRule === 'isrequired')) {\n                        continue;\n                    }\n\n                    // ignore empty string, and anything not a function\n                    if (currentRule !== '' && typeof funcToCall === 'function') {\n                        if (funcToCall.call($el, value, param) === false) {\n                            result = currentRule;\n                            break;\n                        }\n                    }\n                }\n\n                return result;\n            },\n\n            /*\n             * validate an individual element\n             * @param e {object}: event object\n             * @return {string|boolean}: returns the first failed rule, or true if validation has passed\n             */\n            element: function (e) {\n                var $el = $(this),\n                    value = app.element.getValue($el),\n                    result = true,\n                    rulesString,\n                    $tempEl;\n\n                // handle radio and input types - select all elements with that name\n                if (app.element.isCheckable($el)) {\n                    $el = app.element.getByAttribute($el, 'name');\n                }\n\n                // fetch rules once we have all the necessary elements\n                rulesString = app.element.getRules($el);\n\n                // use required function to check if value is empty\n                if (!app.validate.required.call($el, value)) {\n                    // return 'required' or 'isrequired' if in validation rules, otherwise pass\n                    result = (' ' + rulesString.toLowerCase() + ' ').indexOf(' required ') > -1 ? 'required' : (' ' + rulesString.toLowerCase() + ' ').indexOf(' isrequired ') > -1 ? 'isrequired' : true;\n                } else {\n                    // if value is not empty, cycle through any remaining rules\n                    result = app.validate.rules($el, rulesString.split(' '), value, false);\n                }\n\n                app.element.setClasses($el, result);\n                return result;\n            },\n\n            /*\n             * method to trigger validation based on element - used in API\n             * @param value {HTMLElement|jQuery object|string} optional:\n             *      if form element(s) (input, select, textarea), will validate those elements\n             *      if any other element, will validate all form elements inside\n             *      if given a string, will validate that string against the rules in rules param\n             * @param tests {string|array} optional: set of rules to run against the value - defaults to 'required'\n             *      if a string, must be space delimited e.g. 'required alpha minlength:5' or ['required', 'alpha', 'minlength:5']\n             *      is not used if the value param is not a string\n             * @return {boolean|string}: returns true if all validation has passed (or there were no elements to validate)\n             *      validation assumed to have passed if testing against non-existent rules\n             *      if checking a string and the validation does not pass, will return the first rule that fails\n             */\n            handle: function (value, tests, checkRequired) {\n                var $elems;\n\n                // handle value variant\n                if (typeof value !== 'object' || value === null) {\n                    // if no rules passed in, assume required only\n                    if (typeof tests === 'undefined' || tests === null || tests === '') {\n                        tests = ['required'];\n                    }\n\n                    // turn into array\n                    if (typeof tests === 'string') {\n                        tests = tests.split(' ');\n                    }\n\n                    // context\n                    return app.validate.rules({}, tests, value, checkRequired || false);\n                } else {\n                    // validate all set forms by default\n                    if (!($elems = $(value || '[data-validation=\"set\"]')).length) {\n                        return true; // if no elements exist, return true\n                    }\n\n                    // generate string of error classes to remove\n                    rules.setErrorClassString();\n\n                    // validate\n                    return (/input|select|textarea/i).test($elems[0].nodeName)\n                        ? !$elems.each(app.validate.element).filter('validation-failed').length\n                        : app.validate.all.call($elems);\n                }\n            }\n        },\n\n        /*\n         * given holder element as context\n         */\n        prep: function () {\n            // reset the data-validation attribute so that events are not bound on subsequent init calls\n            var $form = $(this).attr('data-validation', 'set');\n\n            // bind full submit handling to the form submit event if using a normal form\n            if (this.nodeName === 'FORM') {\n                $form.on('submit', function (e) {\n                    return app.validate.handle(this);\n                });\n            }\n\n            // bind to validation-trigger elements - use the closest form to allow nested forms\n            $form.on('click', '.validation-trigger', function (e) {\n                app.validate.handle($(this).closest('[data-validation=\"set\"]'));\n            });\n\n            // bind individual input change events\n            $form.on('change', 'input, select, textarea', function (e) {\n                // check if the form itself has a parent form as we only want to fire the delegated event once\n                var prevent = $form.parent().closest('[data-validation=\"set\"]').length ||\n                    // if radio or checkbox, check if any in the same group have a data-validation attribute\n                    // otherwise, just check if validation attribute exists on the element\n                    (app.element.isCheckable($(this))\n                        ? !app.element.getByAttribute($(this), 'name').filter('[data-validation]').length\n                        : typeof $(this).data('validation') === 'undefined');\n\n                if (!prevent) {\n                    app.validate.handle(this);\n                }\n            });\n        },\n\n        /*\n         * primary setup method\n         */\n        init: function () {\n            $('[data-validation=\"true\"]').each(app.prep);\n        }\n    };\n\n    // set rules aliases and any modifications\n    rules.setRules();\n\n    // expose\n    return {\n        init: app.init,\n        addTest: rules.addTest,\n        getFormData: app.getFormData,\n        validate: function (value, rules) {\n            return app.validate.handle(value, rules, true);\n        }\n    };\n\n}));\n"],"sourceRoot":"/source/"}