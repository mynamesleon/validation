{"version":3,"sources":["validation.js"],"names":["root","factory","define","amd","$","validation","jQuery","this","app","rules","required","validate","val","$elem","nodeName","length","element","isCheckable","filter","alpha","regex","test","alphanumeric","email","RegExp","join","min","parseFloat","max","range","separators","rangeArr","replace","split","toCheck","match","minlength","getByAttribute","maxlength","rangelength","minwords","trim","maxwords","rangewords","number","isNaN","isFinite","integer","digits","checked","unchecked","confirm","selector","$current","func","arg","i","a","String","prototype","charAt","undefined","slice","Error","substr","e","toStringProto","Object","toString","reg","call","date","Date","url","ipaddress","ipv4","ipv6","creditcard","notAllowed","nonDigits","currentDigit","n","numToCheck","bEven","nDigit","parseInt","colour","keywords","hex","hsl","hsla","rgb","rgba","types","thisType","j","expr","attr","inArray","addTest","name","toLowerCase","param","setRuleAliases","thisAlias","aliases","ip","color","numeric","format","pattern","regexp","equals","equalto","matches","setErrorClassString","r","hasOwnProperty","push","errorClassString","getFormData","$form","attribute","document","$inputs","find","not","data","each","attrArray","$input","currentDataPoint","indexOf","getValue","elem","$el","$result","result","value","isArray","setClasses","removeClass","triggerHandler","addClass","getRules","stored","arr","all","$holder","$elems","rule","currentRule","checkRequired","splitRule","shift","rulesArr","rulesString","handle","tests","prep","on","closest","prevent","parent","init"],"mappings":";;;;;;;CASC,SAAUA,EAAMC,GACb,YAC2B,mBAAhBD,GAAKE,QAAyBF,EAAKE,OAAOC,IAEjDH,EAAKE,QAAQ,UAAW,SAAUE,GAI9B,MAAQJ,GAAKK,WAAaJ,EAAQG,KAItCJ,EAAKK,WAAaJ,EAAQD,EAAKM,SAGrCC,KAAM,SAAUH,GACd,YAIA,IAAII,MAMAC,GAOIC,UACIC,SAAU,SAAUC,GAChB,GAAIC,GAAQT,EAAEG,KAGd,OAA0B,WAAtBM,EAAM,GAAGC,SACFF,GAAOA,EAAIG,OAAS,GAAa,MAARH,GAAuB,OAARA,EAI/CJ,EAAIQ,QAAQC,YAAYJ,GACjBA,EAAMK,OAAO,YAAYH,OAAS,EAI1B,gBAARH,KACEA,EAINA,EAAIG,OAAS,IAS5BI,OACIC,MAAO,gBACPT,SAAU,SAAUC,GAChB,MAAOH,GAAMU,MAAMC,MAAMC,KAAKT,KAStCU,cACIF,MAAO,eACPT,SAAU,SAAUC,GAChB,MAAOH,GAAMa,aAAaF,MAAMC,KAAKT,KAU7CW,OACIH,MAAO,GAAII,SACP,oDACA,uCACA,4DACFC,KAAK,KACPd,SAAU,SAAUC,GAChB,MAAOH,GAAMc,MAAMH,MAAMC,KAAKT,KAUtCc,KACIf,SAAU,SAAUC,EAAKc,GACrB,MAAOC,YAAWf,IAAQe,WAAWD,KAU7CE,KACIjB,SAAU,SAAUC,EAAKgB,GACrB,MAAOD,YAAWf,IAAQe,WAAWC,KAU7CC,OACIC,WAAY,cACZnB,SAAU,SAAUC,EAAKiB,GACrB,GAAIE,GAAWF,EAAMG,QAAQvB,EAAMoB,MAAMC,WAAY,KAAKG,MAAM,KAC5DC,EAAUP,WAAWf,EAEzB,OAAOsB,IAAWP,WAAWI,EAAS,KAAOG,GAAWP,WAAWI,EAAS,MAUpFI,OACIxB,SAAU,SAAUC,EAAKuB,GACrB,MAAOvB,KAAQuB,IAUvBC,WACIzB,SAAU,SAAUC,EAAKc,GACrB,GAAIQ,IAAW1B,EAAIQ,QAAQC,YAAYb,EAAEG,OACnCC,EAAIQ,QAAQqB,eAAejC,EAAEG,MAAO,QAAQW,OAAO,YACnDN,GAAKG,MAEX,OAAOmB,IAAWP,WAAWD,KAUrCY,WACI3B,SAAU,SAAUC,EAAKgB,GACrB,GAAIM,IAAW1B,EAAIQ,QAAQC,YAAYb,EAAEG,OACnCC,EAAIQ,QAAQqB,eAAejC,EAAEG,MAAO,QAAQW,OAAO,YACnDN,GAAKG,MAEX,OAAOmB,IAAWP,WAAWC,KAUrCW,aACIT,WAAY,gBACZnB,SAAU,SAAUC,EAAKiB,GACrB,GAAIE,GAAWF,EAAMG,QAAQvB,EAAM8B,YAAYT,WAAY,KAAKG,MAAM,KAClEC,GAAW1B,EAAIQ,QAAQC,YAAYb,EAAEG,OACxBC,EAAIQ,QAAQqB,eAAejC,EAAEG,MAAO,QAAQW,OAAO,YACnDN,GAAKG,MAEtB,OAAOmB,IAAWP,WAAWI,EAAS,KAAOG,GAAWP,WAAWI,EAAS,MAUpFS,UACI7B,SAAU,SAAUC,EAAKc,GACrB,MAAOtB,GAAEqC,KAAK7B,GAAKqB,MAAM,OAAOlB,QAAUY,WAAWD,KAU7DgB,UACI/B,SAAU,SAAUC,EAAKgB,GACrB,MAAOxB,GAAEqC,KAAK7B,GAAKqB,MAAM,OAAOlB,QAAUY,WAAWC,KAU7De,YACIb,WAAY,gBACZnB,SAAU,SAAUC,EAAKiB,GACrB,GAAIE,GAAWF,EAAMG,QAAQvB,EAAMkC,WAAWb,WAAY,KAAKG,MAAM,KACjEC,EAAU9B,EAAEqC,KAAK7B,GAAKqB,MAAM,OAAOlB,MAEvC,OAAOmB,IAAWP,WAAWI,EAAS,KAAOG,GAAWP,WAAWI,EAAS,MAUpFa,QACIjC,SAAU,SAAUC,GAChB,OAAQiC,MAAMlB,WAAWf,KAASkC,SAASlC,KASnDmC,SACI3B,MAAO,UACPT,SAAU,SAAUC,GAChB,MAAOH,GAAMsC,QAAQ3B,MAAMC,KAAKT,KASxCoC,QACI5B,MAAO,QACPT,SAAU,SAAUC,GAChB,MAAOH,GAAMuC,OAAO5B,MAAMC,KAAKT,KAQvCqC,SACItC,SAAU,SAAUC,GAChB,MAAOJ,GAAIQ,QAAQC,YAAYb,EAAEG,OAC3BC,EAAIQ,QAAQqB,eAAejC,EAAEG,MAAO,QAAQW,OAAO,YAAYH,OAAS,EAChE,OAARH,IAQdsC,WACIvC,SAAU,SAAUC,GAChB,MAAOJ,GAAIQ,QAAQC,YAAYb,EAAEG,OAC+C,IAA1EC,EAAIQ,QAAQqB,eAAejC,EAAEG,MAAO,QAAQW,OAAO,YAAYH,OACvD,OAARH,IAaduC,SACIxC,SAAU,SAAUC,EAAKwC,GACrB,GAEIC,GACAtC,EACAuC,EACAC,EACAC,EANAC,IACSC,QAAOC,UAAUC,MAU9B,IAAwB,gBAAbR,IAAgD,MAAvBA,EAASQ,OAAO,IAAuD,MAAzCR,EAASQ,OAAOR,EAASrC,OAAS,GAAY,CAM5G,IAJA0C,EAAIrD,EAAEqC,MAAMW,EAAW,KAAKnB,MAAM,MAAMR,KAAK,WAAWO,QAAQ,KAAM,KAAKC,MAAM,WACjFlB,EAAS0C,EAAE1C,OAGNyC,EAAI,EAAGA,EAAIzC,EAAQyC,GAAK,EAKzB,GAJAF,EAAOG,EAAED,GACTD,EAAME,EAAED,EAAI,GAGC,MAATF,GAAoC,mBAAbD,GAGvBA,EAAWjD,EAAU,SAARmD,EAAiBhD,KAAe,UAARgD,EAAkBM,OAAYN,OAChE,CAAA,GAAyB,MAArBD,EAAKQ,MAAM,EAAG,GAErB,KAAM,IAAIC,OAAM,iDAGhBT,GAAOA,EAAKtB,QAAQ,IAAK,IAGzBuB,EAAc,UAARA,EAAkBM,OAAYN,EAAIS,OAAO,EAAGT,EAAIxC,OAAS,GAG/DsC,EAAWA,EAASC,GAAMC,GAIlC,IACI,MAAO3C,KAAQyC,EAASzC,MAC1B,MAAOqD,GACL,KAAM,IAAIF,OAAM,kCAIxB,MAAOnD,KAAQR,EAAEgD,GAAUxC,QAUnCQ,OACI8C,cAAeC,OAAOR,UAAUS,SAChCzD,SAAU,SAAUC,EAAKyD,GACrB,MAAmB,gBAARA,GACA,GAAI7C,QAAO6C,GAAKhD,KAAKT,GACmB,oBAAxCH,EAAMW,MAAM8C,cAAcI,KAAKD,GAC/BA,EAAIhD,KAAKT,GADb,SAWf2D,MACInD,MAAO,cACPT,SAAU,SAAUC,GAChB,OAAQH,EAAM8D,KAAKnD,MAAMC,KAAK,GAAImD,MAAK5D,GAAKwD,cAUpDK,KACIrD,MAAO,GAAII,SACP,yBACA,uBACA,MACA,mCACA,gDACA,qDACA,yCACA,6CACA,kDACA,6DACA,iEACA,sCACA,QACA,iBACA,iBACA,KACFC,KAAK,IAAK,KACZd,SAAU,SAAUC,GAChB,MAAOH,GAAMgE,IAAIrD,MAAMC,KAAKT,KAUpC8D,WACIC,KAAM,GAAInD,SACN,sDACA,2CACA,gCACA,KACFC,KAAK,KAEPmD,KAAM,GAAIpD,SACN,QACA,IACA,gDACA,sIACA,gJACA,sKACA,0KACA,0KACA,0KACA,oJACA,IACA,iDACFC,KAAK,KAEPd,SAAU,SAAUC,GAChB,MAAOH,GAAMiE,UAAUC,KAAKtD,KAAKT,IAAQH,EAAMiE,UAAUE,KAAKvD,KAAKT,KAS3EiE,YACIC,WAAY,GAAItD,QAAO,eACvBuD,UAAW,MACXpE,SAAU,SAAUC,GAEhB,GAAIH,EAAMoE,WAAWC,WAAWzD,KAAKT,GACjC,OAAO,CAGX,IAEIoE,GAEAC,EAJAC,EAAa,EACbC,GAAQ,EAERC,EAAS,CAOb,IAHAxE,EAAMA,EAAIoB,QAAQvB,EAAMoE,WAAWE,UAAW,IAG1CnE,EAAIG,OAAS,IAAMH,EAAIG,OAAS,GAChC,OAAO,CAGX,KAAKkE,EAAIrE,EAAIG,OAAS,EAAGkE,GAAK,EAAGA,GAAK,EAClCD,EAAepE,EAAIgD,OAAOqB,GAC1BG,EAASC,SAASL,EAAc,IAC5BG,IACKC,GAAU,GAAK,IAChBA,GAAU,GAGlBF,GAAcE,EACdD,GAASA,CAGb,OAAQD,GAAa,KAAQ,IAYrCI,QACIxD,WAAY,gBAEZyD,UACI,YAAa,eAAgB,OAAQ,aAAc,QAAS,QAAS,SAAU,QAAS,iBAAkB,OAC1G,aAAc,QAAS,YAAa,YAAa,aAAc,YAAa,QAAS,iBAAkB,WACvG,UAAW,OAAQ,WAAY,WAAY,gBAAiB,WAAY,YAAa,WAAY,YACjG,cAAe,iBAAkB,aAAc,aAAc,UAAW,aAAc,eAAgB,gBACtG,gBAAiB,gBAAiB,gBAAiB,aAAc,WAAY,cAAe,UAAW,UACvG,aAAc,YAAa,cAAe,cAAe,UAAW,YAAa,aAAc,OAAQ,YACvG,OAAQ,QAAS,cAAe,OAAQ,WAAY,UAAW,YAAa,SAAU,QAAS,QAAS,WACxG,gBAAiB,YAAa,eAAgB,YAAa,aAAc,YAAa,uBACtF,YAAa,aAAc,YAAa,YAAa,cAAe,gBAAiB,eAAgB,iBACrG,iBAAkB,iBAAkB,cAAe,OAAQ,YAAa,QAAS,UAAW,SAAU,mBACtG,aAAc,eAAgB,eAAgB,iBAAkB,kBAAmB,oBAAqB,kBACxG,kBAAmB,eAAgB,YAAa,YAAa,WAAY,cAAe,OAAQ,UAAW,QAC3G,YAAa,SAAU,YAAa,SAAU,gBAAiB,YAAa,gBAAiB,gBAAiB,aAC9G,YAAa,OAAQ,OAAQ,OAAQ,aAAc,SAAU,MAAO,YAAa,YAAa,cAAe,SAC7G,aAAc,WAAY,WAAY,SAAU,SAAU,UAAW,YAAa,YAAa,YAAa,OAC5G,cAAe,YAAa,MAAO,OAAQ,UAAW,SAAU,cAAe,YAAa,SAAU,QAAS,QAC/G,aAAc,SAAU,eAG5BnE,OACIoE,KACI,sCAEJC,KACI,0FAEJC,MACI,6FAEJC,KACI,0GACA,6EAEJC,MACI,2FACA,8EAIRjF,SAAU,SAAUC,EAAKiF,GACrB,GAEIC,GACAtC,EACAuC,EAJAR,EAAW9E,EAAM6E,OAAOC,SACxBS,EAAOvF,EAAM6E,OAAOlE,KAMxB,IAA6B,UAAzBhB,EAAEG,MAAM0F,KAAK,QACb,MAAOD,GAAKR,IAAI,GAAGnE,KAAKT,EAY5B,IARAiF,EAAQA,IAAU,WAAY,MAAO,MAAO,OAAQ,MAAO,QAGtC,gBAAVA,KACPA,EAAQA,EAAM7D,QAAQvB,EAAM6E,OAAOxD,WAAY,KAAKG,MAAM,MAI1D7B,EAAE8F,QAAQ,WAAYL,IAAS,GAAMzF,EAAE8F,QAAQtF,EAAK2E,IAAY,EAChE,OAAO,CAIX,KAAK/B,EAAI,EAAGA,EAAIqC,EAAM9E,OAAQyC,GAAK,EAG/B,GAFAsC,EAAWD,EAAMrC,GAEa,gBAAnBwC,GAAKF,GACZ,IAAKC,EAAI,EAAGA,EAAIC,EAAKF,GAAU/E,OAAQgF,GAAK,EAExC,GAAIC,EAAKF,GAAUC,GAAG1E,KAAKT,GACvB,OAAO,CAOvB,QAAO,IASfuF,QAAS,SAAUC,EAAM/E,GACrB,GAAoB,gBAAT+E,IAAqC,kBAAT/E,GACnC,KAAM,IAAI0C,OAAM,qDAIpBqC,GAAOA,EAAKC,cAGe,mBAAhB5F,GAAM2F,KACb3F,EAAM2F,IACFzF,SAAU,SAAUC,EAAK0F,GACrB,MAAOjF,GAAKiD,KAAK/D,KAAMK,EAAK0F,OAS5CC,eAAgB,WACZ,GAAI/C,GAEAgD,EACAC,GACI,WAAY,QAAS,eAAgB,QAAS,UAAW,SAAU,UAAW,SAAU,UAAW,UACnG,SAAU,KAAM,YAAa,UAAW,YAAa,OAAQ,MAAO,aAAc,QAAS,UAE/F1F,EAAS0F,EAAQ1F,MAUrB,KAPAN,EAAMiG,GAAKjG,EAAMiE,UACjBjE,EAAMkG,MAAQlG,EAAM6E,OACpB7E,EAAMmG,QAAUnG,EAAMmC,OACtBnC,EAAMoG,OAASpG,EAAMqG,QAAUrG,EAAMsG,OAAStG,EAAMW,MACpDX,EAAMuG,OAASvG,EAAMwG,QAAUxG,EAAMyG,QAAUzG,EAAM0B,MAGhDqB,EAAI,EAAGA,EAAIzC,EAAQyC,GAAK,EACzBgD,EAAYC,EAAQjD,GACpB/C,EAAM,KAAO+F,GAAa/F,EAAM+F,IAOxCW,oBAAqB,WACjB,GAAI3D,GACA4D,GAAK,oBAET,KAAK5D,IAAK/C,GACFA,EAAM4G,eAAe7D,IAA0B,gBAAb/C,GAAM+C,IACxC4D,EAAEE,KAAK,qBAAuB9D,EAItC/C,GAAM8G,iBAAmBH,EAAE3F,KAAK,MAoa5C,OA7ZAjB,IAQIgH,YAAa,SAAUC,EAAOC,GAE1BD,EAAQA,GAASrH,EAAE,2BACnBsH,EAAYA,GAAa,OAGJ,gBAAVD,IAAuBA,EAAM1G,SACpC0G,EAAQrH,EAAEuH,UAGd,IAAIC,GAAUH,EAAMI,KAAK,2BAA2BC,IAAI,oCACpDC,IA2CJ,OAxCAH,GAAQI,KAAK,WACT,GAGIC,GACAlH,EACAyC,EALA0E,EAAS9H,EAAEG,MACX0F,EAAOiC,EAAOjC,KAAKyB,GACnBS,EAAmBJ,CAMvB,IAAoB,mBAAT9B,GAAX,CAUA,GALIA,EAAKmC,QAAQ,MAAO,GAAMnC,EAAKmC,QAAQ,MAAO,IAC9CnC,EAAOA,EAAKhE,MAAM,KAAKR,KAAK,KAAKQ,MAAM,KAAKR,KAAK,KAIjDwE,EAAKmC,QAAQ,QAAS,EAEtB,YADAL,EAAK9B,GAAQzF,EAAIQ,QAAQqH,SAASH,EAAQR,GAS9C,KAJAO,EAAYhC,EAAKhE,MAAM,KACvBlB,EAASkH,EAAUlH,OAGdyC,EAAI,EAAGA,EAAIzC,EAAS,EAAGyC,GAAK,EACiB,mBAAnC2E,GAAiBF,EAAUzE,MAClC2E,EAAiBF,EAAUzE,QAE/B2E,EAAmBA,EAAiBF,EAAUzE,GAIlD2E,GAAiBF,EAAUlH,EAAS,IAAMP,EAAIQ,QAAQqH,SAASH,EAAQR,MAGpEK,GAMX/G,SAOIC,YAAa,SAAUqH,GACnB,MAAO,kBAAoBjH,KAAKjB,EAAEkI,GAAMrC,KAAK,UASjD5D,eAAgB,SAAUkG,EAAKb,GAC3BA,EAAYA,GAAa,MACzB,IAAIc,GAAUpI,EAAE,IAAMsH,EAAY,KAAOa,EAAItC,KAAKyB,GAAa,KAC/D,OAAOc,GAAQzH,OAASyH,EAAUD,GAStCF,SAAU,SAAUE,EAAKb,GACrB,GAAIe,KAwBJ,OAvBAf,GAAYA,GAAa,OAGrBlH,EAAIQ,QAAQC,YAAYsH,KACxBA,EAAM/H,EAAIQ,QAAQqB,eAAekG,EAAK,QAAQrH,OAAO,aAIzDqH,EAAIP,KAAK,WACL,GAAIU,GAAQtI,EAAEG,MAAMK,KAEhBR,GAAEuI,QAAQD,KACVA,EAAQA,EAAMjH,KAAK,MAEvBgH,EAAOnB,KAAKoB,KAIM,IAAlBD,EAAO1H,QACP0H,EAAOnB,MAAK,GAITmB,EAAOhH,KAAK,MAQvBmH,WAAY,SAAUL,EAAKE,GAEvBF,EAAIM,YAAYpI,EAAM8G,kBAIlBkB,KAAW,EACXF,EAAIO,eAAe,qBAEnBP,EAAIQ,SAAS,uCAAyCN,GAAQK,eAAe,oBAAqBL,IAS1GO,SAAU,SAAUT,GAChB,GAAIE,MACAQ,IAGJ,OAAmB,KAAfV,EAAIxH,OACGwH,EAAIR,KAAK,eAIpBQ,EAAIP,KAAK,WACL,GAEIjH,GACAyC,EAHA/C,EAAQL,EAAEG,MAAMwH,KAAK,cACrBmB,IAKJ,IAAqB,mBAAVzI,GAOX,IAHAyI,EAAMzI,EAAMwB,MAAM,KAClBlB,EAASmI,EAAInI,OAERyC,EAAI,EAAGA,EAAIzC,EAAQyC,GAAK,EAEK,mBAAnByF,GAAOC,EAAI1F,MAClBiF,EAAOnB,KAAK4B,EAAI1F,IAEhByF,EAAOC,EAAI1F,KAAM,KAItBiF,EAAOhH,KAAK,QAQ3Bd,UAOIwI,IAAK,SAAUlF,GACX,GAAImF,GAAUhJ,EAAEG,MACZ8I,EAASD,EAAQvB,KAAK,6EAI1B,OAFAwB,GAAOrB,KAAKxH,EAAIG,SAASK,SAErBqI,EAAOnI,OAAO,sBAAsBH,QACpCqI,EAAQL,SAAS,qBAAqBD,eAAe,oBAAqBtI,EAAIgH,YAAY4B,KACnF,IAGXA,EAAQP,YAAY,qBAAqBC,eAAe,oBAAqBtI,EAAIgH,YAAY4B,KACtF,IAWXE,KAAM,SAAUf,EAAKG,EAAOa,EAAaC,GACrC,GAAIlD,GACAmD,CAGJ,IAAoB,KAAhBF,EAAJ,CAeA,GAVIA,EAAYnB,QAAQ,MAAO,IAC3BqB,EAAYF,EAAYtH,MAAM,KAC9BsH,EAAcE,EAAUC,QACxBpD,EAAQmD,EAAUhI,KAAK,KAAKQ,MAAM,YAAYR,KAAK,MAIvD8H,EAAcA,EAAYlD,cAAcpE,MAAM,YAAYR,KAAK,KAG7B,gBAAvBhB,GAAM8I,GACb,KAAM,IAAIxF,OAAM,oBAAuBwF,EAAc,6CAAiDA,EAAc,kDAIxH,IAAIC,KAAkB,GAA0B,aAAhBD,GAA8C,eAAhBA,EAK9D,MAAI9I,GAAM8I,GAAa5I,SAAS2D,KAAKiE,EAAKG,EAAOpC,MAAW,EACjDiD,EADX,SAaJ9I,MAAO,SAAU8H,EAAKoB,EAAUjB,EAAOc,GACnC,GAAqB,mBAAVd,GACP,KAAM,IAAI3E,OAAM,oBAGpB,IAEIP,GAFAzC,EAAS4I,EAAS5I,OAClB0H,GAAS,CAIb,KAAKjF,EAAI,EAAGA,EAAIzC,EAAQyC,GAAK,EAEzB,GADAiF,EAASjI,EAAIG,SAAS2I,KAAKf,EAAKG,EAAOiB,EAASnG,GAAIgG,GAC9B,gBAAXf,GACP,MAAOA,EAIf,QAAO,GAQXzH,QAAS,SAAUiD,GACf,GAGI2F,GAHArB,EAAMnI,EAAEG,MACRmI,EAAQlI,EAAIQ,QAAQqH,SAASE,GAC7BE,GAAS,CA0Bb,OArBIjI,GAAIQ,QAAQC,YAAYsH,KACxBA,EAAM/H,EAAIQ,QAAQqB,eAAekG,EAAK,SAI1CqB,EAAcpJ,EAAIQ,QAAQgI,SAAST,GAY/BE,EATChI,EAAMC,SAASC,SAAS2D,KAAKiE,EAAKG,GAS1BlI,EAAIG,SAASF,MAAM8H,EAAKqB,EAAY3H,MAAM,KAAMyG,GAAO,IAPtD,IAAMkB,EAAYvD,cAAgB,KAAK+B,QAAQ,eAAgB,EACnE,cACC,IAAMwB,EAAYvD,cAAgB,KAAK+B,QAAQ,iBAAkB,IAClE,aAOV5H,EAAIQ,QAAQ4H,WAAWL,EAAKE,GACrBA,GAgBXoB,OAAQ,SAAUnB,EAAOoB,EAAON,GAC5B,GAAIH,EAGJ,OAAqB,gBAAVX,IAAgC,OAAVA,GAER,mBAAVoB,IAAmC,OAAVA,GAA4B,KAAVA,IAClDA,GAAS,aAIQ,gBAAVA,KACPA,EAAQA,EAAM7H,MAAM,MAIjBzB,EAAIG,SAASF,SAAUqJ,EAAOpB,EAAOc,IAAiB,MAGvDH,EAASjJ,EAAEsI,GAAS,4BAA4B3H,SAKtDN,EAAM0G,sBAGC,yBAA2B9F,KAAKgI,EAAO,GAAGvI,WAC1CuI,EAAOrB,KAAKxH,EAAIG,SAASK,SAASE,OAAO,qBAAqBH,OAC/DP,EAAIG,SAASwI,IAAI7E,KAAK+E,MAQxCU,KAAM,WAEF,GAAItC,GAAQrH,EAAEG,MAAM0F,KAAK,kBAAmB,MAGtB,UAAlB1F,KAAKO,UACL2G,EAAMuC,GAAG,SAAU,SAAU/F,GACzB,MAAOzD,GAAIG,SAASkJ,OAAOtJ,QAKnCkH,EAAMuC,GAAG,QAAS,sBAAuB,SAAU/F,GAC/CzD,EAAIG,SAASkJ,OAAOzJ,EAAEG,MAAM0J,QAAQ,8BAIxCxC,EAAMuC,GAAG,SAAU,0BAA2B,SAAU/F,GAEpD,GAAIiG,GAAUzC,EAAM0C,SAASF,QAAQ,2BAA2BlJ,SAG3DP,EAAIQ,QAAQC,YAAYb,EAAEG,QACpBC,EAAIQ,QAAQqB,eAAejC,EAAEG,MAAO,QAAQW,OAAO,qBAAqBH,OACnC,mBAA/BX,GAAEG,MAAMwH,KAAK,cAEzBmC,IACD1J,EAAIG,SAASkJ,OAAOtJ,SAQhC6J,KAAM,WACFhK,EAAE,4BAA4B4H,KAAKxH,EAAIuJ,QAK/CtJ,EAAM8F,kBAIF6D,KAAM5J,EAAI4J,KACVjE,QAAS1F,EAAM0F,QACfqB,YAAahH,EAAIgH,YACjB7G,SAAU,SAAU+H,EAAOjI,GACvB,MAAOD,GAAIG,SAASkJ,OAAOnB,EAAOjI,GAAO","file":"validation.min.js","sourcesContent":["/**\n * validation\n * Leon Slater\n * http://mynamesleon.com\n * github.com/mynamesleon/validation\n * @license: MIT\n */\n\n/** @namespace validation */\n(function (root, factory) {\n    'use strict';\n    if (typeof root.define === 'function' && root.define.amd) {\n        // AMD. Register as an anonymous module.\n        root.define(['jQuery'], function ($) {\n            // Also create a global in case some scripts\n            // that are loaded still are looking for\n            // a global even when an AMD loader is in use.\n            return (root.validation = factory($));\n        });\n    } else {\n        // Browser globals\n        root.validation = factory(root.jQuery);\n    }\n\n}(this, function ($) {\n    'use strict';\n\n    // todo: finish setting up tests for all validation rules\n\n    var app = {},\n\n        /**\n         * all validation rules called in element context\n         * should always return a boolean\n         */\n        rules = {\n\n            /**\n             * required rule stored here to prevent being overidden - called in element context\n             * @param val {string}\n             * @return {boolean}\n             */\n            required: {\n                validate: function (val) {\n                    var $elem = $(this);\n\n                    // handle select - check that a value exists, is not empty, and is not 0 or -1\n                    if ($elem[0].nodeName === 'SELECT') {\n                        return val && val.length > 0 && val !== '0' && val !== '-1';\n                    }\n\n                    // handle radio and checkbox\n                    if (app.element.isCheckable($elem)) {\n                        return $elem.filter(':checked').length > 0;\n                    }\n\n                    // handle any non string values\n                    if (typeof val !== 'string') {\n                        return !!val;\n                    }\n\n                    // default\n                    return val.length > 0;\n                }\n            },\n\n            /**\n             * letters only\n             * @param val {string}\n             * @return {boolean}\n             */\n            alpha: {\n                regex: /^[a-zA-Z\\s]+$/,\n                validate: function (val) {\n                    return rules.alpha.regex.test(val);\n                }\n            },\n\n            /**\n             * letters and numbers only\n             * @param val {string}\n             * @return {boolean}\n             */\n            alphanumeric: {\n                regex: /^[a-z0-9]+$/i,\n                validate: function (val) {\n                    return rules.alphanumeric.regex.test(val);\n                }\n            },\n\n            /**\n             * email test - allows formats as simple as name@domain\n             * https://html.spec.whatwg.org/multipage/forms.html#valid-e-mail-address\n             * @param val {string}\n             * @return {boolean}\n             */\n            email: {\n                regex: new RegExp([\n                    '^[a-zA-Z0-9.!#$%&\\'*+\\/=?\\\\^_`{|}~\\\\-]+@[a-zA-Z0-9]',\n                    '(?:[a-zA-Z0-9\\\\-]{0,61}[a-zA-Z0-9])?',\n                    '(?:\\\\.[a-zA-Z0-9](?:[a-zA-Z0-9\\\\-]{0,61}[a-zA-Z0-9])?)*$'\n                ].join('')),\n                validate: function (val) {\n                    return rules.email.regex.test(val);\n                }\n            },\n\n            /**\n             * minimum number\n             * @param val {string}\n             * @param min {string|number}\n             * @return {boolean}\n             */\n            min: {\n                validate: function (val, min) {\n                    return parseFloat(val) >= parseFloat(min);\n                }\n            },\n\n            /**\n             * maximum number\n             * @param val {string}\n             * @param max {string|number}\n             * @return {boolean}\n             */\n            max: {\n                validate: function (val, max) {\n                    return parseFloat(val) <= parseFloat(max);\n                }\n            },\n\n            /**\n             * range between numbers\n             * @param val {string}\n             * @param range {string}: space (if not in data attribute), comma, hyphen, underscore, pipe or colon delimited\n             * @return {boolean}\n             */\n            range: {\n                separators: /[\\,\\_\\|\\:]/g,\n                validate: function (val, range) {\n                    var rangeArr = range.replace(rules.range.separators, ' ').split(' '),\n                        toCheck = parseFloat(val);\n\n                    return toCheck >= parseFloat(rangeArr[0]) && toCheck <= parseFloat(rangeArr[1]);\n                }\n            },\n\n            /**\n             * match a specific value\n             * @param val {string}\n             * @param match {string}\n             * @return {boolean}\n             */\n            match: {\n                validate: function (val, match) {\n                    return val === match;\n                }\n            },\n\n            /**\n             * minlength of a string, or minimum number of checked inputs\n             * @param val {string}\n             * @param min {string|number}\n             * @return {boolean}\n             */\n            minlength: {\n                validate: function (val, min) {\n                    var toCheck = (app.element.isCheckable($(this))\n                        ? app.element.getByAttribute($(this), 'name').filter(':checked')\n                        : val).length;\n\n                    return toCheck >= parseFloat(min);\n                }\n            },\n\n            /**\n             * maxlength of a string, or maximum number of checked inputs\n             * @param val {string}\n             * @param max {string|number}\n             * @return {boolean}\n             */\n            maxlength: {\n                validate: function (val, max) {\n                    var toCheck = (app.element.isCheckable($(this))\n                        ? app.element.getByAttribute($(this), 'name').filter(':checked')\n                        : val).length;\n\n                    return toCheck <= parseFloat(max);\n                }\n            },\n\n            /**\n             * range between character length\n             * @param val {string}\n             * @param range {string}: space (if not in data attribute), comma, hyphen, underscore, pipe or colon delimited\n             * @return {boolean}\n             */\n            rangelength: {\n                separators: /[\\,\\-\\_\\|\\:]/g,\n                validate: function (val, range) {\n                    var rangeArr = range.replace(rules.rangelength.separators, ' ').split(' '),\n                        toCheck = (app.element.isCheckable($(this))\n                                   ? app.element.getByAttribute($(this), 'name').filter(':checked')\n                                   : val).length;\n\n                    return toCheck >= parseFloat(rangeArr[0]) && toCheck <= parseFloat(rangeArr[1]);\n                }\n            },\n\n            /**\n             * word count minimum\n             * @param val {string}\n             * @param min {string}\n             * @return {boolean}\n             */\n            minwords: {\n                validate: function (val, min) {\n                    return $.trim(val).split(/\\s+/).length >= parseFloat(min);\n                }\n            },\n\n            /**\n             * word count maximum\n             * @param val {string}\n             * @param min {string}\n             * @return {boolean}\n             */\n            maxwords: {\n                validate: function (val, max) {\n                    return $.trim(val).split(/\\s+/).length <= parseFloat(max);\n                }\n            },\n\n            /**\n             * word count range\n             * @param val {string}\n             * @param range {string}: space (if not in data attribute), comma, hyphen, underscore, pipe or colon delimited\n             * @return {boolean}\n             */\n            rangewords: {\n                separators: /[\\,\\-\\_\\|\\:]/g,\n                validate: function (val, range) {\n                    var rangeArr = range.replace(rules.rangewords.separators, ' ').split(' '),\n                        toCheck = $.trim(val).split(/\\s+/).length;\n\n                    return toCheck >= parseFloat(rangeArr[0]) && toCheck <= parseFloat(rangeArr[1]);\n                }\n            },\n\n            /**\n             * number only - allows decimals\n             * http://stackoverflow.com/questions/18082/validate-decimal-numbers-in-javascript-isnumeric#1830844\n             * @param val {string}\n             * @return {boolean}\n             */\n            number: {\n                validate: function (val) {\n                    return !isNaN(parseFloat(val)) && isFinite(val);\n                }\n            },\n\n            /**\n             * integer only (allows negatives)\n             * @param val {string}\n             * @return {boolean}\n             */\n            integer: {\n                regex: /^-?\\d+$/,\n                validate: function (val) {\n                    return rules.integer.regex.test(val);\n                }\n            },\n\n            /**\n             * digits only\n             * @param val {string}\n             * @return {boolean}\n             */\n            digits: {\n                regex: /^\\d+$/,\n                validate: function (val) {\n                    return rules.digits.regex.test(val);\n                }\n            },\n\n            /**\n             * must be checked\n             * @return {boolean}\n             */\n            checked: {\n                validate: function (val) {\n                    return app.element.isCheckable($(this))\n                        ? app.element.getByAttribute($(this), 'name').filter(':checked').length > 0\n                        : val !== '-1';\n                }\n            },\n\n            /**\n             * must be unchecked\n             * @return {boolean}\n             */\n            unchecked: {\n                validate: function (val) {\n                    return app.element.isCheckable($(this))\n                        ? app.element.getByAttribute($(this), 'name').filter(':checked').length === 0\n                        : val === '-1';\n                }\n            },\n\n            /**\n             * test value against the value of another input - must use {!space} for spaces needed in the selector\n             * @param val {string}\n             * @param selector {string|jQuery object}: if string, can include basic jQuery methods\n             *      e.g. \"$(this).parent().prev().find('input[type=\\\"text\\\"]')\"\n             *      deliberately restricted so that each jQuery method used can only take one string paramater\n             *      specific handling is included to handle the 'this' keyword when included on data-validation attribute\n             * @return {boolean}\n             */\n            confirm: {\n                validate: function (val, selector) {\n                    var a = [],\n                        charAt = String.prototype.charAt,\n                        $current,\n                        length,\n                        func,\n                        arg,\n                        i;\n\n                    // if it starts with a $, and ends with ')', assume full jquery selector has been provided\n                    // allow use of $(this) at start only\n                    // allow use of simple chained methods - only let them accept one string parameter e.g. $(this).parents('.elem').find('input')\n                    if (typeof selector === 'string' && selector.charAt(0) === '$' && selector.charAt(selector.length - 1) === ')') {\n                        // add in '(empty)' for methods that will take no argument\n                        a = $.trim((selector + ' ').split('()').join('(empty)').replace(') ', '')).split(/[\\)\\(]/g);\n                        length = a.length;\n\n                        // things get messy now...\n                        for (i = 0; i < length; i += 2) {\n                            func = a[i];\n                            arg = a[i + 1];\n\n                            // handle the function to be used\n                            if (func === '$' && typeof $current === 'undefined') {\n                                // handle starting case\n                                // if given 'this', use current context; if given empty, set to undefined, otherwise use as is\n                                $current = $(arg === 'this' ? this : arg === 'empty' ? undefined : arg);\n                            } else if (func.slice(0, 1) !== '.') {\n                                // if not starting case, make sure the var starts with a '.' to indicate a jQuery method\n                                throw new Error('Incorrectly formatted jQuery selector function');\n                            } else {\n                                // get the next jQuery method\n                                func = func.replace('.', '');\n\n                                // once past starting case, only allow undefined or strings\n                                arg = arg === 'empty' ? undefined : arg.substr(1, arg.length - 2);\n\n                                // update $current\n                                $current = $current[func](arg);\n                            }\n                        }\n\n                        try {\n                            return val === $current.val();\n                        } catch (e) {\n                            throw new Error('Failed to parse your selector');\n                        }\n                    }\n\n                    return val === $(selector).val();\n                }\n            },\n\n            /**\n             * custom regular expression check - must use {!space} for spaces needed in regex\n             * @param val {string}\n             * @param reg {string|object}: will be a string when included in the validation data attribute\n             * @return {boolean}\n             */\n            regex: {\n                toStringProto: Object.prototype.toString,\n                validate: function (val, reg) {\n                    if (typeof reg === 'string') {\n                        return new RegExp(reg).test(val);\n                    } else if (rules.regex.toStringProto.call(reg) === '[object RegExp]') {\n                        return reg.test(val);\n                    }\n                }\n            },\n\n            /**\n             * date test\n             * @param val {string}\n             * @return {boolean}\n             */\n            date: {\n                regex: /Invalid|NaN/,\n                validate: function (val) {\n                    return !rules.date.regex.test(new Date(val).toString());\n                }\n            },\n\n            /**\n             * url test\n             * https://gist.github.com/dperini/729294\n             * @param val {string}\n             * @return {boolean}\n             */\n            url: {\n                regex: new RegExp([\n                    '^(?:(?:https?|ftp)://)',\n                    '(?:\\\\S+(?::\\\\S*)?@)?',\n                    '(?:',\n                    '(?!(?:10|127)(?:\\\\.\\\\d{1,3}){3})',\n                    '(?!(?:169\\\\.254|192\\\\.168)(?:\\\\.\\\\d{1,3}){2})',\n                    '(?!172\\\\.(?:1[6-9]|2\\\\d|3[0-1])(?:\\\\.\\\\d{1,3}){2})',\n                    '(?:[1-9]\\\\d?|1\\\\d\\\\d|2[01]\\\\d|22[0-3])',\n                    '(?:\\\\.(?:1?\\\\d{1,2}|2[0-4]\\\\d|25[0-5])){2}',\n                    '(?:\\\\.(?:[1-9]\\\\d?|1\\\\d\\\\d|2[0-4]\\\\d|25[0-4]))|',\n                    '(?:(?:[a-z\\\\u00a1-\\\\uffff0-9]-*)*[a-z\\\\u00a1-\\\\uffff0-9]+)',\n                    '(?:\\\\.(?:[a-z\\\\u00a1-\\\\uffff0-9]-*)*[a-z\\\\u00a1-\\\\uffff0-9]+)*',\n                    '(?:\\\\.(?:[a-z\\\\u00a1-\\\\uffff]{2,}))',\n                    '\\\\.?)',\n                    '(?::\\\\d{2,5})?',\n                    '(?:[/?#]\\\\S*)?',\n                    '$'\n                ].join(''), 'i'),\n                validate: function (val) {\n                    return rules.url.regex.test(val);\n                }\n            },\n\n            /**\n             * ipv4 test - allows leading zeros\n             * expressions derived from regular expressions cookbook second edition (august 2012)\n             * @param val {string}\n             * @return {boolean}\n             */\n            ipaddress: {\n                ipv4: new RegExp([\n                    '^(?:(?:25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)\\\\.){3}',\n                    '(?:25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)',\n                    '(\\/([0-9]|[1-2][0-9]|3[0-2]))?', // allow cidr notation\n                    '$'\n                ].join('')),\n\n                ipv6: new RegExp([\n                    '^\\\\s*',\n                    '(',\n                    '(([0-9A-Fa-f]{1,4}:){7}([0-9A-Fa-f]{1,4}|:))|',\n                    '(([0-9A-Fa-f]{1,4}:){6}(:[0-9A-Fa-f]{1,4}|((25[0-5]|2[0-4]\\\\d|1\\\\d\\\\d|[1-9]?\\\\d)(\\\\.(25[0-5]|2[0-4]\\\\d|1\\\\d\\\\d|[1-9]?\\\\d)){3})|:))|',\n                    '(([0-9A-Fa-f]{1,4}:){5}(((:[0-9A-Fa-f]{1,4}){1,2})|:((25[0-5]|2[0-4]\\\\d|1\\\\d\\\\d|[1-9]?\\\\d)(\\\\.(25[0-5]|2[0-4]\\\\d|1\\\\d\\\\d|[1-9]?\\\\d)){3})|:))|',\n                    '(([0-9A-Fa-f]{1,4}:){4}(((:[0-9A-Fa-f]{1,4}){1,3})|((:[0-9A-Fa-f]{1,4})?:((25[0-5]|2[0-4]\\\\d|1\\\\d\\\\d|[1-9]?\\\\d)(\\\\.(25[0-5]|2[0-4]\\\\d|1\\\\d\\\\d|[1-9]?\\\\d)){3}))|:))|',\n                    '(([0-9A-Fa-f]{1,4}:){3}(((:[0-9A-Fa-f]{1,4}){1,4})|((:[0-9A-Fa-f]{1,4}){0,2}:((25[0-5]|2[0-4]\\\\d|1\\\\d\\\\d|[1-9]?\\\\d)(\\\\.(25[0-5]|2[0-4]\\\\d|1\\\\d\\\\d|[1-9]?\\\\d)){3}))|:))|',\n                    '(([0-9A-Fa-f]{1,4}:){2}(((:[0-9A-Fa-f]{1,4}){1,5})|((:[0-9A-Fa-f]{1,4}){0,3}:((25[0-5]|2[0-4]\\\\d|1\\\\d\\\\d|[1-9]?\\\\d)(\\\\.(25[0-5]|2[0-4]\\\\d|1\\\\d\\\\d|[1-9]?\\\\d)){3}))|:))|',\n                    '(([0-9A-Fa-f]{1,4}:){1}(((:[0-9A-Fa-f]{1,4}){1,6})|((:[0-9A-Fa-f]{1,4}){0,4}:((25[0-5]|2[0-4]\\\\d|1\\\\d\\\\d|[1-9]?\\\\d)(\\\\.(25[0-5]|2[0-4]\\\\d|1\\\\d\\\\d|[1-9]?\\\\d)){3}))|:))|',\n                    '(:(((:[0-9A-Fa-f]{1,4}){1,7})|((:[0-9A-Fa-f]{1,4}){0,5}:((25[0-5]|2[0-4]\\\\d|1\\\\d\\\\d|[1-9]?\\\\d)(\\\\.(25[0-5]|2[0-4]\\\\d|1\\\\d\\\\d|[1-9]?\\\\d)){3}))|:))',\n                    ')',\n                    '(%.+)?\\\\s*(\\/(\\\\d|\\\\d\\\\d|1[0-1]\\\\d|12[0-8]))?$' // allow cidr notation\n                ].join('')),\n\n                validate: function (val) {\n                    return rules.ipaddress.ipv4.test(val) || rules.ipaddress.ipv6.test(val);\n                }\n            },\n\n            /**\n             * credit card check\n             * @param val {string}\n             * @return {boolean}\n             */\n            creditcard: {\n                notAllowed: new RegExp('[^0-9 \\\\-]+'),\n                nonDigits: /\\D/g,\n                validate: function (val) {\n                    // accept spaces, digits and dashes only\n                    if (rules.creditcard.notAllowed.test(val)) {\n                        return false;\n                    }\n\n                    var numToCheck = 0,\n                        bEven = false,\n                        currentDigit,\n                        nDigit = 0,\n                        n;\n\n                    // remove anything that is not a digit\n                    val = val.replace(rules.creditcard.nonDigits, '');\n\n                    // estimated min and max length to allow\n                    if (val.length < 13 || val.length > 19) {\n                        return false;\n                    }\n\n                    for (n = val.length - 1; n >= 0; n -= 1) {\n                        currentDigit = val.charAt(n);\n                        nDigit = parseInt(currentDigit, 10);\n                        if (bEven) {\n                            if ((nDigit *= 2) > 9) {\n                                nDigit -= 9;\n                            }\n                        }\n                        numToCheck += nDigit;\n                        bEven = !bEven;\n                    }\n\n                    return (numToCheck % 10) === 0;\n                }\n            },\n\n            /**\n             * colour validation\n             * @param val {string}\n             * @param types {string|array} optional: string or array of colour types\n             *      allowed colour types: keywords, hex, hsl, hsla, rgb, rgba - defaults to all\n             *      can be comma, space, hyphen, underscore, pipe, or colon delimited as a string\n             *      cannot be space delimited when used in data-validation attribute\n             */\n            colour: {\n                separators: /[\\,\\-\\_\\|\\:]/g,\n\n                keywords: [\n                    'aliceblue', 'antiquewhite', 'aqua', 'aquamarine', 'azure', 'beige', 'bisque', 'black', 'blanchedalmond', 'blue',\n                    'blueviolet', 'brown', 'burlywood', 'cadetblue', 'chartreuse', 'chocolate', 'coral', 'cornflowerblue', 'cornsilk',\n                    'crimson', 'cyan', 'darkblue', 'darkcyan', 'darkgoldenrod', 'darkgray', 'darkgreen', 'darkgrey', 'darkkhaki',\n                    'darkmagenta', 'darkolivegreen', 'darkorange', 'darkorchid', 'darkred', 'darksalmon', 'darkseagreen', 'darkslateblue',\n                    'darkslategray', 'darkslategrey', 'darkturquoise', 'darkviolet', 'deeppink', 'deepskyblue', 'dimgray', 'dimgrey',\n                    'dodgerblue', 'firebrick', 'floralwhite', 'forestgreen', 'fuchsia', 'gainsboro', 'ghostwhite', 'gold', 'goldenrod',\n                    'gray', 'green', 'greenyellow', 'grey', 'honeydew', 'hotpink', 'indianred', 'indigo', 'ivory', 'khaki', 'lavender',\n                    'lavenderblush', 'lawngreen', 'lemonchiffon', 'lightblue', 'lightcoral', 'lightcyan', 'lightgoldenrodyellow',\n                    'lightgray', 'lightgreen', 'lightgrey', 'lightpink', 'lightsalmon', 'lightseagreen', 'lightskyblue', 'lightslategray',\n                    'lightslategrey', 'lightsteelblue', 'lightyellow', 'lime', 'limegreen', 'linen', 'magenta', 'maroon', 'mediumaquamarine',\n                    'mediumblue', 'mediumorchid', 'mediumpurple', 'mediumseagreen', 'mediumslateblue', 'mediumspringgreen', 'mediumturquoise',\n                    'mediumvioletred', 'midnightblue', 'mintcream', 'mistyrose', 'moccasin', 'navajowhite', 'navy', 'oldlace', 'olive',\n                    'olivedrab', 'orange', 'orangered', 'orchid', 'palegoldenrod', 'palegreen', 'paleturquoise', 'palevioletred', 'papayawhip',\n                    'peachpuff', 'peru', 'pink', 'plum', 'powderblue', 'purple', 'red', 'rosybrown', 'royalblue', 'saddlebrown', 'salmon',\n                    'sandybrown', 'seagreen', 'seashell', 'sienna', 'silver', 'skyblue', 'slateblue', 'slategray', 'slategrey', 'snow',\n                    'springgreen', 'steelblue', 'tan', 'teal', 'thistle', 'tomato', 'transparent', 'turquoise', 'violet', 'wheat', 'white',\n                    'whitesmoke', 'yellow', 'yellowgreen'\n                ],\n\n                regex: {\n                    hex: [\n                        /(^#[0-9A-F]{6}$)|(^#[0-9A-F]{3}$)/i\n                    ],\n                    hsl: [\n                        /^hsl\\((\\s*(-?\\d+)\\s*,)(\\s*(\\b(0?\\d{1,2}|100)\\b%)\\s*,)(\\s*(\\b(0?\\d{1,2}|100)\\b%)\\s*)\\)$/\n                    ],\n                    hsla: [\n                        /^hsla\\((\\s*(-?\\d+)\\s*,)(\\s*(\\b(0?\\d{1,2}|100)\\b%)\\s*,){2}(\\s*(0?(\\.\\d+)?|1(\\.0+)?)\\s*)\\)$/\n                    ],\n                    rgb: [\n                        /^rgb\\((\\s*(\\b([01]?\\d{1,2}|2[0-4]\\d|25[0-5])\\b)\\s*,){2}(\\s*(\\b([01]?\\d{1,2}|2[0-4]\\d|25[0-5])\\b)\\s*)\\)$/,\n                        /^rgb\\((\\s*(\\b(0?\\d{1,2}|100)\\b%)\\s*,){2}(\\s*(\\b(0?\\d{1,2}|100)\\b%)\\s*)\\)$/\n                    ],\n                    rgba: [\n                        /^rgba\\((\\s*(\\b([01]?\\d{1,2}|2[0-4]\\d|25[0-5])\\b)\\s*,){3}(\\s*(0?(\\.\\d+)?|1(\\.0+)?)\\s*)\\)$/,\n                        /^rgba\\((\\s*(\\b(0?\\d{1,2}|100)\\b%)\\s*,){3}(\\s*(0?(\\.\\d+)?|1(\\.0+)?)\\s*)\\)$/\n                    ]\n                },\n\n                validate: function (val, types) {\n                    var keywords = rules.colour.keywords,\n                        expr = rules.colour.regex,\n                        thisType,\n                        i,\n                        j;\n\n                    // if using a colour input, test against the hex regex straight away\n                    if ($(this).attr('type') === 'color') {\n                        return expr.hex[0].test(val);\n                    }\n\n                    // default to allow all types\n                    types = types || ['keywords', 'hex', 'hsl', 'hsla', 'rgb', 'rgba'];\n\n                    // if types passed in as a string, replace the possible separators and make array\n                    if (typeof types === 'string') {\n                        types = types.replace(rules.colour.separators, ' ').split(' ');\n                    }\n\n                    // keywords check\n                    if ($.inArray('keywords', types) > -1 && $.inArray(val, keywords) > -1) {\n                        return true;\n                    }\n\n                    // cycle through types\n                    for (i = 0; i < types.length; i += 1) {\n                        thisType = types[i];\n                        // if we have expressions for that type, check them\n                        if (typeof expr[thisType] === 'object') {\n                            for (j = 0; j < expr[thisType].length; j += 1) {\n                                // if it passes, return true immediately\n                                if (expr[thisType][j].test(val)) {\n                                    return true;\n                                }\n                            }\n                        }\n                    }\n\n                    // return false by default\n                    return false;\n                }\n            },\n\n            /**\n             * add a test to the internal rules\n             * @param name {string}\n             * @param test {function}\n             */\n            addTest: function (name, test) {\n                if (typeof name !== 'string' || typeof test !== 'function') {\n                    throw new Error('A string and a function are required to add a test');\n                }\n\n                // only store rules as lowercase for consistency, and to protect methods\n                name = name.toLowerCase();\n\n                // do not override any existing rules\n                if (typeof rules[name] === 'undefined') {\n                    rules[name] = {\n                        validate: function (val, param) {\n                            return test.call(this, val, param);\n                        }\n                    };\n                }\n            },\n\n            /**\n             * set rule aliases\n             */\n            setRuleAliases: function () {\n                var i,\n                    j,\n                    thisAlias,\n                    aliases = [\n                        'required', 'alpha', 'alphanumeric', 'email', 'equalto', 'format', 'pattern', 'number', 'numeric', 'integer',\n                        'digits', 'ip', 'ipaddress', 'checked', 'unchecked', 'date', 'url', 'creditcard', 'color', 'colour'\n                    ],\n                    length = aliases.length;\n\n                // set specific aliases\n                rules.ip = rules.ipaddress;\n                rules.color = rules.colour;\n                rules.numeric = rules.number;\n                rules.format = rules.pattern = rules.regexp = rules.regex;\n                rules.equals = rules.equalto = rules.matches = rules.match;\n\n                // create is- aliases\n                for (i = 0; i < length; i += 1) {\n                    thisAlias = aliases[i];\n                    rules['is' + thisAlias] = rules[thisAlias];\n                }\n            },\n\n            /**\n             * generate a space delimited string of all rules\n             */\n            setErrorClassString: function () {\n                var i,\n                    r = ['validation-failed'];\n\n                for (i in rules) {\n                    if (rules.hasOwnProperty(i) && typeof rules[i] === 'object') {\n                        r.push('validation-failed-' + i);\n                    }\n                }\n\n                rules.errorClassString = r.join(' ');\n            }\n        };\n\n    /**\n     * main application methods\n     */\n    app = {\n\n        /**\n         * get data from all inputs in the form\n         * @param $form {jQuery object}\n         * @param attribute {string} optional: attribute to use - defaults to name\n         * @return {object}\n         */\n        getFormData: function ($form, attribute) {\n            // handle defaults\n            $form = $form || $('[data-validation=\"set\"]');\n            attribute = attribute || 'name';\n\n            // default to finding all inouts on the page if no validation has been set\n            if (typeof $form !== 'object' || !$form.length) {\n                $form = $(document);\n            }\n\n            var $inputs = $form.find('input, select, textarea').not('[type=\"submit\"], [type=\"button\"]'),\n                data = {};\n\n            // update data object with input value\n            $inputs.each(function () {\n                var $input = $(this),\n                    attr = $input.attr(attribute),\n                    currentDataPoint = data,\n                    attrArray,\n                    length,\n                    i;\n\n                // do not proceed if attribute does not exist for that element\n                if (typeof attr === 'undefined') {\n                    return;\n                }\n\n                // handle key style naming e.g. primary[secondary][tertiary]\n                if (attr.indexOf('[') > -1 && attr.indexOf(']') > -1) {\n                    attr = attr.split('[').join('.').split(']').join('');\n                }\n\n                // standard case\n                if (attr.indexOf('.') === -1) {\n                    data[attr] = app.element.getValue($input, attribute);\n                    return;\n                }\n\n                // set needed vars for recursive entry creation for chosen attribute\n                attrArray = attr.split('.');\n                length = attrArray.length;\n\n                // set the level in the object that we want to add the new property\n                for (i = 0; i < length - 1; i += 1) {\n                    if (typeof currentDataPoint[attrArray[i]] === 'undefined') {\n                        currentDataPoint[attrArray[i]] = {};\n                    }\n                    currentDataPoint = currentDataPoint[attrArray[i]];\n                }\n\n                // use length - 1 so the final entry in the array is used as the property name\n                currentDataPoint[attrArray[length - 1]] = app.element.getValue($input, attribute);\n            });\n\n            return data;\n        },\n\n        /**\n         * element handling\n         */\n        element: {\n\n            /**\n             * check if element is checkbox or radio type\n             * @param elem {HTMLElement|jQuery object}\n             * @return {boolean}\n             */\n            isCheckable: function (elem) {\n                return (/radio|checkbox/i).test($(elem).attr('type'));\n            },\n\n            /**\n             * get all elements with matching attribute value\n             * @param $el {jQuery object}\n             * @param attribute {string} optional: defaults to 'name'\n             * @return {jQuery object}: returns $el if none were founding with matching attribute value\n             */\n            getByAttribute: function ($el, attribute) {\n                attribute = attribute || 'name';\n                var $result = $('[' + attribute + '=\"' + $el.attr(attribute) + '\"]');\n                return $result.length ? $result : $el;\n            },\n\n            /**\n             * get element value\n             * @param $el {jQuery object}\n             * @param attribute {string} optional: attribute to use when selecting multiple elements\n             * @return {string}\n             */\n            getValue: function ($el, attribute) {\n                var result = [];\n                attribute = attribute || 'name';\n\n                // get by name for radio or input types\n                if (app.element.isCheckable($el)) {\n                    $el = app.element.getByAttribute($el, 'name').filter(':checked');\n                }\n\n                // cycle through elements to handle elements with the same name\n                $el.each(function () {\n                    var value = $(this).val();\n                    // check for array e.g. multi-select\n                    if ($.isArray(value)) {\n                        value = value.join(',');\n                    }\n                    result.push(value);\n                });\n\n                // if nothing has been added to the result, set to -1 by default\n                if (result.length === 0) {\n                    result.push(-1);\n                }\n\n                // always return a string - join group values with commas\n                return result.join(',');\n            },\n\n            /**\n             * toggle element classes based on validation, and trigger custom events\n             * @param $el {jQuery object}\n             * @param result {boolean|string}: true if validation has passed, otherwise string indicating failed rule\n             */\n            setClasses: function ($el, result) {\n                // remove all rule classes e.g. failed-number\n                $el.removeClass(rules.errorClassString);\n\n                // toggle remaining needed classes and trigger validation event\n                // use triggerHandler to prevent event bubbling\n                if (result === true) {\n                    $el.triggerHandler('validation.passed');\n                } else {\n                    $el.addClass('validation-failed validation-failed-' + result).triggerHandler('validation.failed', result);\n                }\n            },\n\n            /**\n             * build space delimitted rules string\n             * @param $el {jQuery object}: elements to use when getting validation rules\n             * @return {string}\n             */\n            getRules: function ($el) {\n                var result = [],\n                    stored = {};\n\n                // if only one element, return the validation data from it\n                if ($el.length === 1) {\n                    return $el.data('validation');\n                }\n\n                // if multiple, cycle and add\n                $el.each(function () {\n                    var rules = $(this).data('validation'),\n                        arr = [],\n                        length,\n                        i;\n\n                    // continue if no validation rules are specified on the element\n                    if (typeof rules === 'undefined') {\n                        return;\n                    }\n\n                    arr = rules.split(' ');\n                    length = arr.length;\n\n                    for (i = 0; i < length; i += 1) {\n                        // check that the validation rule has not been added already\n                        if (typeof stored[arr[i]] === 'undefined') {\n                            result.push(arr[i]);\n                            // update stored object to indicate that this rule has been added\n                            stored[arr[i]] = true;\n                        }\n                    }\n                });\n                return result.join(' ');\n            }\n\n        },\n\n        /**\n         * validate storage\n         */\n        validate: {\n\n            /**\n             * trigger validation on whole form - validates all set form elements\n             * @param e {object}: event object\n             * @return {boolean}: if validation has passed\n             */\n            all: function (e) {\n                var $holder = $(this),\n                    $elems = $holder.find('input[data-validation], select[data-validation], textarea[data-validation]');\n\n                $elems.each(app.validate.element);\n\n                if ($elems.filter('.validation-failed').length) {\n                    $holder.addClass('validation-failed').triggerHandler('validation.failed', app.getFormData($holder));\n                    return false; // return value, and prevents default action if event object is passed in\n                }\n\n                $holder.removeClass('validation-failed').triggerHandler('validation.passed', app.getFormData($holder));\n                return true;\n            },\n\n            /**\n             * test an individual rule\n             * @param $el {jQuery object}\n             * @aram value {string}\n             * @param currentRule {string}\n             * @param checkRequired {boolean}: internal only - whether to run a standard check on the required rule\n             * @return {string|undefined}: returns the rule if the check fails, otherwise returns nothing\n             */\n            rule: function ($el, value, currentRule, checkRequired) {\n                var param,\n                    splitRule;\n\n                // ignore empty strings\n                if (currentRule === '') {\n                    return;\n                }\n\n                // extract any provided param - use shift and join to handle multiple colons in value\n                if (currentRule.indexOf(':') > -1) {\n                    splitRule = currentRule.split(':');\n                    currentRule = splitRule.shift();\n                    param = splitRule.join(':').split('{!space}').join(' ');\n                }\n\n                // all validation rules are stored as lower case\n                currentRule = currentRule.toLowerCase().split('{!space}').join(' ');\n\n                // check that the rule exists\n                if (typeof rules[currentRule] !== 'object') {\n                    throw new Error('Validation rule \\'' + currentRule + '\\' does not exist. Use validation.addTest(\\'' + currentRule + '\\', function () { /** your test */ }) to add it.');\n                }\n\n                // ionly proceed on required rule when called via validation.validate\n                if (checkRequired === false && (currentRule === 'required' || currentRule === 'isrequired')) {\n                    return;\n                }\n\n                // run the check - if it fails, return the rule\n                if (rules[currentRule].validate.call($el, value, param) === false) {\n                    return currentRule;\n                }\n            },\n\n            /**\n             * cycle through all rules for an element\n             * @param $el {jQuery object}\n             * @param rulesArr {array}: array of rule strings\n             * @aram value {string}: element value\n             * @param checkRequired {boolean}: internal only\n             * @return {boolean|string}: a string containing the failed rule, or true if validation passed\n             */\n            rules: function ($el, rulesArr, value, checkRequired) {\n                if (typeof value === 'undefined') {\n                    throw new Error('No value provided');\n                }\n\n                var length = rulesArr.length,\n                    result = true,\n                    i;\n\n                // cycle through remaining rules\n                for (i = 0; i < length; i += 1) {\n                    result = app.validate.rule($el, value, rulesArr[i], checkRequired);\n                    if (typeof result === 'string') {\n                        return result;\n                    }\n                }\n\n                return true;\n            },\n\n            /**\n             * validate an individual element\n             * @param e {object}: event object\n             * @return {string|boolean}: returns the first failed rule, or true if validation has passed\n             */\n            element: function (e) {\n                var $el = $(this),\n                    value = app.element.getValue($el),\n                    result = true,\n                    rulesString,\n                    $tempEl;\n\n                // handle radio and input types - select all elements with that name\n                if (app.element.isCheckable($el)) {\n                    $el = app.element.getByAttribute($el, 'name');\n                }\n\n                // fetch rules once we have all the necessary elements\n                rulesString = app.element.getRules($el);\n\n                // use required function to check if value is empty\n                if (!rules.required.validate.call($el, value)) {\n                    // return 'required' or 'isrequired' if in validation rules, otherwise pass\n                    result = (' ' + rulesString.toLowerCase() + ' ').indexOf(' required ') > -1\n                        ? 'required'\n                        : (' ' + rulesString.toLowerCase() + ' ').indexOf(' isrequired ') > -1\n                        ? 'isrequired'\n                        : true;\n                } else {\n                    // if value is not empty, cycle through any remaining rules\n                    result = app.validate.rules($el, rulesString.split(' '), value, false);\n                }\n\n                app.element.setClasses($el, result);\n                return result;\n            },\n\n            /**\n             * method to trigger validation based on element - used in API\n             * @param value {HTMLElement|jQuery object|string} optional:\n             *      if form element(s) (input, select, textarea), will validate those elements\n             *      if any other element, will validate all form elements inside\n             *      if given a string, will validate that string against the rules in rules param\n             * @param tests {string|array} optional: set of rules to run against the value - defaults to 'required'\n             *      if a string, must be space delimited e.g. 'required alpha minlength:5' or ['required', 'alpha', 'minlength:5']\n             *      is not used if the value param is not a string\n             * @return {boolean|string}: returns true if all validation has passed (or there were no elements to validate)\n             *      validation assumed to have passed if testing against non-existent rules\n             *      if checking a string and the validation does not pass, will return the first rule that fails\n             */\n            handle: function (value, tests, checkRequired) {\n                var $elems;\n\n                // handle value variant\n                if (typeof value !== 'object' || value === null) {\n                    // if no rules passed in, assume required only\n                    if (typeof tests === 'undefined' || tests === null || tests === '') {\n                        tests = ['required'];\n                    }\n\n                    // turn into array\n                    if (typeof tests === 'string') {\n                        tests = tests.split(' ');\n                    }\n\n                    // context\n                    return app.validate.rules({}, tests, value, checkRequired || false);\n                } else {\n                    // validate all set forms by default\n                    if (!($elems = $(value || '[data-validation=\"set\"]')).length) {\n                        return true; // if no elements exist, return true\n                    }\n\n                    // generate string of error classes to remove\n                    rules.setErrorClassString();\n\n                    // validate\n                    return (/input|select|textarea/i).test($elems[0].nodeName)\n                        ? !$elems.each(app.validate.element).filter('validation-failed').length\n                        : app.validate.all.call($elems);\n                }\n            }\n        },\n\n        /**\n         * given holder element as context\n         */\n        prep: function () {\n            // reset the data-validation attribute so that events are not bound on subsequent init calls\n            var $form = $(this).attr('data-validation', 'set');\n\n            // bind full submit handling to the form submit event if using a normal form\n            if (this.nodeName === 'FORM') {\n                $form.on('submit', function (e) {\n                    return app.validate.handle(this);\n                });\n            }\n\n            // bind to validation-trigger elements - use the closest form to allow nested forms\n            $form.on('click', '.validation-trigger', function (e) {\n                app.validate.handle($(this).closest('[data-validation=\"set\"]'));\n            });\n\n            // bind individual input change events\n            $form.on('change', 'input, select, textarea', function (e) {\n                // check if the form itself has a parent form as we only want to fire the delegated event once\n                var prevent = $form.parent().closest('[data-validation=\"set\"]').length ||\n                    // if radio or checkbox, check if any in the same group have a data-validation attribute\n                    // otherwise, just check if validation attribute exists on the element\n                    (app.element.isCheckable($(this))\n                        ? !app.element.getByAttribute($(this), 'name').filter('[data-validation]').length\n                        : typeof $(this).data('validation') === 'undefined');\n\n                if (!prevent) {\n                    app.validate.handle(this);\n                }\n            });\n        },\n\n        /**\n         * primary setup method\n         */\n        init: function () {\n            $('[data-validation=\"true\"]').each(app.prep);\n        }\n    };\n\n    // set rules aliases\n    rules.setRuleAliases();\n\n    // expose\n    return {\n        init: app.init,\n        addTest: rules.addTest,\n        getFormData: app.getFormData,\n        validate: function (value, rules) {\n            return app.validate.handle(value, rules, true);\n        }\n    };\n\n}));\n"],"sourceRoot":"/source/"}