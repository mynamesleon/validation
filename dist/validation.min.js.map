{"version":3,"sources":["validation.js"],"names":["root","factory","define","amd","$","validation","jQuery","this","app","rules","required","validate","val","call","alpha","regex","test","alphanumeric","email","RegExp","join","min","parseFloat","max","range","separators","rangeArr","replace","split","toCheck","match","minlength","element","isCheckable","getByAttribute","filter","length","maxlength","rangelength","minwords","trim","maxwords","rangewords","number","isNaN","isFinite","integer","digits","checked","unchecked","confirm","selector","charAt","eval","toStringProto","Object","prototype","toString","reg","date","Date","url","ipaddress","ipv4","ipv6","creditcard","notAllowed","nonDigits","currentDigit","n","numToCheck","bEven","nDigit","parseInt","colour","keywords","hex","hsl","hsla","rgb","rgba","types","thisType","i","j","expr","attr","inArray","addTest","name","Error","toLowerCase","param","setAliases","thisAlias","aliases","ip","color","numeric","format","pattern","regexp","equals","equalto","matches","setErrorClassString","r","hasOwnProperty","push","errorClassString","getFormData","$form","attribute","document","$inputs","find","not","data","each","attrArray","$input","currentDataPoint","indexOf","getValue","elem","$el","$result","result","value","isArray","setClasses","removeClass","triggerHandler","addClass","getRules","stored","arr","$elem","nodeName","all","e","$holder","$elems","rulesArr","currentRule","funcToCall","splitRule","undefined","shift","rulesString","handle","tests","prep","on","closest","prevent","parent","init"],"mappings":"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","file":"validation.min.js","sourcesContent":["/*\n * validation\n * Leon Slater\n * http://mynamesleon.com\n * github.com/mynamesleon/validation\n * @license MIT\n */\n\n(function (root, factory) {\n    'use strict';\n\n    if (typeof root.define === 'function' && root.define.amd) {\n        // AMD. Register as an anonymous module.\n        root.define(['jQuery'], function ($) {\n            // Also create a global in case some scripts\n            // that are loaded still are looking for\n            // a global even when an AMD loader is in use.\n            return (root.validation = factory($));\n        });\n    } else {\n        // Browser globals\n        root.validation = factory(root.jQuery);\n    }\n\n}(this, function ($) {\n    'use strict';\n\n    // todo: parse selector in 'confirm' properly, rather than relying on eval (or remove that option altogether)\n    // todo: set up unit tests for all validation rules\n\n    var app = {},\n\n        /*\n         * all validation rules called in element context\n         * should always return a boolean\n         */\n        rules = {\n\n            /*\n             * required rule - the rule in this object is not called internally\n             * @param val {string}\n             * @return {boolean}\n             */\n            required: {\n                validate: function (val) {\n                    return app.validate.required.call(this, val);\n                }\n            },\n\n            /*\n             * letters only\n             * @param val {string}\n             * @return {boolean}\n             */\n            alpha: {\n                regex: /^[a-zA-Z\\s]+$/,\n                validate: function (val) {\n                    return rules.alpha.regex.test(val);\n                }\n            },\n\n            /*\n             * letters and numbers only\n             * @param val {string}\n             * @return {boolean}\n             */\n            alphanumeric: {\n                regex: /^[a-z0-9]+$/i,\n                validate: function (val) {\n                    return rules.alphanumeric.regex.test(val);\n                }\n            },\n\n            /*\n             * email test - allows formats as simple as name@domain\n             * https://html.spec.whatwg.org/multipage/forms.html#valid-e-mail-address\n             * @param val {string}\n             * @return {boolean}\n             */\n            email: {\n                regex: new RegExp([\n                    '^[a-zA-Z0-9.!#$%&\\'*+\\/=?\\\\^_`{|}~\\\\-]+@[a-zA-Z0-9]',\n                    '(?:[a-zA-Z0-9\\\\-]{0,61}[a-zA-Z0-9])?',\n                    '(?:\\\\.[a-zA-Z0-9](?:[a-zA-Z0-9\\\\-]{0,61}[a-zA-Z0-9])?)*$'\n                ].join('')),\n                validate: function (val) {\n                    return rules.email.regex.test(val);\n                }\n            },\n\n            /*\n             * minimum number\n             * @param val {string}\n             * @param min {string|number}\n             * @return {boolean}\n             */\n            min: {\n                validate: function (val, min) {\n                    return parseFloat(val) >= parseFloat(min);\n                }\n            },\n\n            /*\n             * maximum number\n             * @param val {string}\n             * @param max {string|number}\n             * @return {boolean}\n             */\n            max: {\n                validate: function (val, max) {\n                    return parseFloat(val) <= parseFloat(max);\n                }\n            },\n\n            /*\n             * range between numbers\n             * @param val {string}\n             * @param range {string}: space (if not in data attribute), comma, hyphen, underscore, pipe or colon delimited\n             * @return {boolean}\n             */\n            range: {\n                separators: /[\\,\\-\\_\\|\\:]/g,\n                validate: function (val, range) {\n                    var rangeArr = range.replace(rules.range.separators, ' ').split(' '),\n                        toCheck = parseFloat(val);\n\n                    return toCheck >= parseFloat(rangeArr[0]) && toCheck <= parseFloat(rangeArr[1]);\n                }\n            },\n\n            /*\n             * match a specific value\n             * @param val {string}\n             * @param match {string}\n             * @return {boolean}\n             */\n            match: {\n                validate: function (val, match) {\n                    return val === match;\n                }\n            },\n\n            /*\n             * minlength of a string, or minimum number of checked inputs\n             * @param val {string}\n             * @param min {string|number}\n             * @return {boolean}\n             */\n            minlength: {\n                validate: function (val, min) {\n                    var toCheck = (app.element.isCheckable($(this))\n                        ? app.element.getByAttribute($(this), 'name').filter(':checked')\n                        : val).length;\n\n                    return toCheck >= parseFloat(min);\n                }\n            },\n\n            /*\n             * maxlength of a string, or maximum number of checked inputs\n             * @param val {string}\n             * @param max {string|number}\n             * @return {boolean}\n             */\n            maxlength: {\n                validate: function (val, max) {\n                    var toCheck = (app.element.isCheckable($(this))\n                        ? app.element.getByAttribute($(this), 'name').filter(':checked')\n                        : val).length;\n\n                    return toCheck <= parseFloat(max);\n                }\n            },\n\n            /*\n             * range between character length\n             * @param val {string}\n             * @param range {string}: space (if not in data attribute), comma, hyphen, underscore, pipe or colon delimited\n             * @return {boolean}\n             */\n            rangelength: {\n                separators: /[\\,\\-\\_\\|\\:]/g,\n                validate: function (val, range) {\n                    var rangeArr = range.replace(rules.rangelength.separators, ' ').split(' '),\n                        toCheck = (app.element.isCheckable($(this))\n                                   ? app.element.getByAttribute($(this), 'name').filter(':checked')\n                                   : val).length;\n\n                    return toCheck >= parseFloat(rangeArr[0]) && toCheck <= parseFloat(rangeArr[1]);\n                }\n            },\n\n            /*\n             * word count minimum\n             * @param val {string}\n             * @param min {string}\n             * @return {boolean}\n             */\n            minwords: {\n                validate: function (val, min) {\n                    return $.trim(val).split(/\\s+/).length >= parseFloat(min);\n                }\n            },\n\n            /*\n             * word count maximum\n             * @param val {string}\n             * @param min {string}\n             * @return {boolean}\n             */\n            maxwords: {\n                validate: function (val, max) {\n                    return $.trim(val).split(/\\s+/).length <= parseFloat(max);\n                }\n            },\n\n            /*\n             * word count range\n             * @param val {string}\n             * @param range {string}: space (if not in data attribute), comma, hyphen, underscore, pipe or colon delimited\n             * @return {boolean}\n             */\n            rangewords: {\n                separators: /[,-_|:]/g,\n                validate: function (val, range) {\n                    var rangeArr = range.replace(rules.rangewords.separators, ' ').split(' '),\n                        toCheck = $.trim(val).split(/\\s+/).length;\n\n                    return toCheck >= parseFloat(rangeArr[0]) && toCheck <= parseFloat(rangeArr[1]);\n                }\n            },\n\n            /*\n             * number only - allows decimals\n             * http://stackoverflow.com/questions/18082/validate-decimal-numbers-in-javascript-isnumeric#1830844\n             * @param val {string}\n             * @return {boolean}\n             */\n            number: {\n                validate: function (val) {\n                    return !isNaN(parseFloat(val)) && isFinite(val);\n                }\n            },\n\n            /*\n             * integer only (allows negatives)\n             * @param val {string}\n             * @return {boolean}\n             */\n            integer: {\n                regex: /^-?\\d+$/,\n                validate: function (val) {\n                    return rules.integer.regex.test(val);\n                }\n            },\n\n            /*\n             * digits only\n             * @param val {string}\n             * @return {boolean}\n             */\n            digits: {\n                regex: /^\\d+$/,\n                validate: function (val) {\n                    return rules.digits.regex.test(val);\n                }\n            },\n\n            /*\n             * must be checked\n             * @return {boolean}\n             */\n            checked: {\n                validate: function (val) {\n                    return typeof val === 'undefined' ? app.element.getByAttribute($(this), 'name').filter(':checked').length > 0 : val !== '-1';\n                }\n            },\n\n            /*\n             * must be unchecked\n             * @return {boolean}\n             */\n            unchecked: {\n                validate: function (val) {\n                    return typeof val === 'undefined' ? app.element.getByAttribute($(this), 'name').filter(':checked').length === 0 : val === '-1';\n                }\n            },\n\n            /*\n             * test value against the value of another input - must use {!space} for spaces needed in the selector\n             * @param val {string}\n             * @param selector {string|jQuery object}\n             * @return {boolean}\n             */\n            confirm: {\n                validate: function (val, selector) {\n                    // reminder: spaces in the selector must be replaced with {!space}\n                    if (typeof selector === 'string') {\n                        selector = selector.split('{!space}').join(' ');\n\n                        // if it starts with a $, assume full jquery selector has been provided and use eval to assess it\n                        if (selector.charAt(0) === '$') {\n                            selector = eval(selector);\n                        }\n                    }\n\n                    return val === $(selector).val();\n                }\n            },\n\n            /*\n             * custom regular expression check - must use {!space} for spaces needed in regex\n             * @param val {string}\n             * @param reg {string|object}: will be a string when included in the validation data attribute\n             * @return {boolean}\n             */\n            regex: {\n                toStringProto: Object.prototype.toString,\n                validate: function (val, reg) {\n                    if (typeof reg === 'string') {\n                        return new RegExp(reg.split('{!space}').join(' ')).test(val);\n                    } else if (rules.regex.toStringProto.call(reg) === '[object RegExp]') {\n                        return reg.test(val);\n                    }\n                }\n            },\n\n            /*\n             * date test\n             * @param val {string}\n             * @return {boolean}\n             */\n            date: {\n                regex: /Invalid|NaN/,\n                validate: function (val) {\n                    return !rules.date.regex.test(new Date(val).toString());\n                }\n            },\n\n            /*\n             * url test\n             * https://gist.github.com/dperini/729294\n             * @param val {string}\n             * @return {boolean}\n             */\n            url: {\n                regex: new RegExp([\n                    '^(?:(?:https?|ftp)://)',\n                    '(?:\\\\S+(?::\\\\S*)?@)?',\n                    '(?:',\n                    '(?!(?:10|127)(?:\\\\.\\\\d{1,3}){3})',\n                    '(?!(?:169\\\\.254|192\\\\.168)(?:\\\\.\\\\d{1,3}){2})',\n                    '(?!172\\\\.(?:1[6-9]|2\\\\d|3[0-1])(?:\\\\.\\\\d{1,3}){2})',\n                    '(?:[1-9]\\\\d?|1\\\\d\\\\d|2[01]\\\\d|22[0-3])',\n                    '(?:\\\\.(?:1?\\\\d{1,2}|2[0-4]\\\\d|25[0-5])){2}',\n                    '(?:\\\\.(?:[1-9]\\\\d?|1\\\\d\\\\d|2[0-4]\\\\d|25[0-4]))|',\n                    '(?:(?:[a-z\\\\u00a1-\\\\uffff0-9]-*)*[a-z\\\\u00a1-\\\\uffff0-9]+)',\n                    '(?:\\\\.(?:[a-z\\\\u00a1-\\\\uffff0-9]-*)*[a-z\\\\u00a1-\\\\uffff0-9]+)*',\n                    '(?:\\\\.(?:[a-z\\\\u00a1-\\\\uffff]{2,}))',\n                    '\\\\.?)',\n                    '(?::\\\\d{2,5})?',\n                    '(?:[/?#]\\\\S*)?',\n                    '$'\n                ].join(''), 'i'),\n                validate: function (val) {\n                    return rules.url.regex.test(val);\n                }\n            },\n\n            /*\n             * ipv4 test - allows leading zeros\n             * expressions derived from regular expressions cookbook second edition (august 2012)\n             * @param val {string}\n             * @return {boolean}\n             */\n            ipaddress: {\n                ipv4: new RegExp([\n                    '^(?:(?:25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)\\\\.){3}',\n                    '(?:25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)',\n                    '(\\/([0-9]|[1-2][0-9]|3[0-2]))?', // allow cidr notation\n                    '$'\n                ].join('')),\n\n                ipv6: new RegExp([\n                    '^\\\\s*',\n                    '(',\n                    '(([0-9A-Fa-f]{1,4}:){7}([0-9A-Fa-f]{1,4}|:))|',\n                    '(([0-9A-Fa-f]{1,4}:){6}(:[0-9A-Fa-f]{1,4}|((25[0-5]|2[0-4]\\\\d|1\\\\d\\\\d|[1-9]?\\\\d)(\\\\.(25[0-5]|2[0-4]\\\\d|1\\\\d\\\\d|[1-9]?\\\\d)){3})|:))|',\n                    '(([0-9A-Fa-f]{1,4}:){5}(((:[0-9A-Fa-f]{1,4}){1,2})|:((25[0-5]|2[0-4]\\\\d|1\\\\d\\\\d|[1-9]?\\\\d)(\\\\.(25[0-5]|2[0-4]\\\\d|1\\\\d\\\\d|[1-9]?\\\\d)){3})|:))|',\n                    '(([0-9A-Fa-f]{1,4}:){4}(((:[0-9A-Fa-f]{1,4}){1,3})|((:[0-9A-Fa-f]{1,4})?:((25[0-5]|2[0-4]\\\\d|1\\\\d\\\\d|[1-9]?\\\\d)(\\\\.(25[0-5]|2[0-4]\\\\d|1\\\\d\\\\d|[1-9]?\\\\d)){3}))|:))|',\n                    '(([0-9A-Fa-f]{1,4}:){3}(((:[0-9A-Fa-f]{1,4}){1,4})|((:[0-9A-Fa-f]{1,4}){0,2}:((25[0-5]|2[0-4]\\\\d|1\\\\d\\\\d|[1-9]?\\\\d)(\\\\.(25[0-5]|2[0-4]\\\\d|1\\\\d\\\\d|[1-9]?\\\\d)){3}))|:))|',\n                    '(([0-9A-Fa-f]{1,4}:){2}(((:[0-9A-Fa-f]{1,4}){1,5})|((:[0-9A-Fa-f]{1,4}){0,3}:((25[0-5]|2[0-4]\\\\d|1\\\\d\\\\d|[1-9]?\\\\d)(\\\\.(25[0-5]|2[0-4]\\\\d|1\\\\d\\\\d|[1-9]?\\\\d)){3}))|:))|',\n                    '(([0-9A-Fa-f]{1,4}:){1}(((:[0-9A-Fa-f]{1,4}){1,6})|((:[0-9A-Fa-f]{1,4}){0,4}:((25[0-5]|2[0-4]\\\\d|1\\\\d\\\\d|[1-9]?\\\\d)(\\\\.(25[0-5]|2[0-4]\\\\d|1\\\\d\\\\d|[1-9]?\\\\d)){3}))|:))|',\n                    '(:(((:[0-9A-Fa-f]{1,4}){1,7})|((:[0-9A-Fa-f]{1,4}){0,5}:((25[0-5]|2[0-4]\\\\d|1\\\\d\\\\d|[1-9]?\\\\d)(\\\\.(25[0-5]|2[0-4]\\\\d|1\\\\d\\\\d|[1-9]?\\\\d)){3}))|:))',\n                    ')',\n                    '(%.+)?\\\\s*(\\/(\\\\d|\\\\d\\\\d|1[0-1]\\\\d|12[0-8]))?$' // allow cidr notation\n                ].join('')),\n\n                validate: function (val) {\n                    return rules.ipaddress.ipv4.test(val) || rules.ipaddress.ipv6.test(val);\n                }\n            },\n\n            /*\n             * credit card check\n             * @param val {string}\n             * @return {boolean}\n             */\n            creditcard: {\n                notAllowed: new RegExp('[^0-9 \\\\-]+'),\n                nonDigits: /\\D/g,\n                validate: function (val) {\n                    // accept spaces, digits and dashes only\n                    if (rules.creditcard.notAllowed.test(val)) {\n                        return false;\n                    }\n\n                    var numToCheck = 0,\n                        bEven = false,\n                        currentDigit,\n                        nDigit = 0,\n                        n;\n\n                    // remove anything that is not a digit\n                    val = val.replace(rules.creditcard.nonDigits, '');\n\n                    // estimated min and max length to allow\n                    if (val.length < 13 || val.length > 19) {\n                        return false;\n                    }\n\n                    for (n = val.length - 1; n >= 0; n -= 1) {\n                        currentDigit = val.charAt(n);\n                        nDigit = parseInt(currentDigit, 10);\n                        if (bEven) {\n                            if ((nDigit *= 2) > 9) {\n                                nDigit -= 9;\n                            }\n                        }\n                        numToCheck += nDigit;\n                        bEven = !bEven;\n                    }\n\n                    return (numToCheck % 10) === 0;\n                }\n            },\n\n            /*\n             * colour validation\n             * @param val {string}\n             * @param types {string|array} optional: string or array of colour types\n             *      allowed colour types: keywords, hex, hsl, hsla, rgb, rgba - defaults to all\n             *      can be comma, space, hyphen, underscore, pipe, or colon delimited as a string\n             *      cannot be space delimited when used in data-validation attribute\n             */\n            colour: {\n                separators: /[\\,\\-\\_\\|\\:]/g,\n\n                keywords: [\n                    'aliceblue', 'antiquewhite', 'aqua', 'aquamarine', 'azure', 'beige', 'bisque', 'black', 'blanchedalmond', 'blue',\n                    'blueviolet', 'brown', 'burlywood', 'cadetblue', 'chartreuse', 'chocolate', 'coral', 'cornflowerblue', 'cornsilk',\n                    'crimson', 'cyan', 'darkblue', 'darkcyan', 'darkgoldenrod', 'darkgray', 'darkgreen', 'darkgrey', 'darkkhaki',\n                    'darkmagenta', 'darkolivegreen', 'darkorange', 'darkorchid', 'darkred', 'darksalmon', 'darkseagreen', 'darkslateblue',\n                    'darkslategray', 'darkslategrey', 'darkturquoise', 'darkviolet', 'deeppink', 'deepskyblue', 'dimgray', 'dimgrey',\n                    'dodgerblue', 'firebrick', 'floralwhite', 'forestgreen', 'fuchsia', 'gainsboro', 'ghostwhite', 'gold', 'goldenrod',\n                    'gray', 'green', 'greenyellow', 'grey', 'honeydew', 'hotpink', 'indianred', 'indigo', 'ivory', 'khaki', 'lavender',\n                    'lavenderblush', 'lawngreen', 'lemonchiffon', 'lightblue', 'lightcoral', 'lightcyan', 'lightgoldenrodyellow',\n                    'lightgray', 'lightgreen', 'lightgrey', 'lightpink', 'lightsalmon', 'lightseagreen', 'lightskyblue', 'lightslategray',\n                    'lightslategrey', 'lightsteelblue', 'lightyellow', 'lime', 'limegreen', 'linen', 'magenta', 'maroon', 'mediumaquamarine',\n                    'mediumblue', 'mediumorchid', 'mediumpurple', 'mediumseagreen', 'mediumslateblue', 'mediumspringgreen', 'mediumturquoise',\n                    'mediumvioletred', 'midnightblue', 'mintcream', 'mistyrose', 'moccasin', 'navajowhite', 'navy', 'oldlace', 'olive',\n                    'olivedrab', 'orange', 'orangered', 'orchid', 'palegoldenrod', 'palegreen', 'paleturquoise', 'palevioletred', 'papayawhip',\n                    'peachpuff', 'peru', 'pink', 'plum', 'powderblue', 'purple', 'red', 'rosybrown', 'royalblue', 'saddlebrown', 'salmon',\n                    'sandybrown', 'seagreen', 'seashell', 'sienna', 'silver', 'skyblue', 'slateblue', 'slategray', 'slategrey', 'snow',\n                    'springgreen', 'steelblue', 'tan', 'teal', 'thistle', 'tomato', 'transparent', 'turquoise', 'violet', 'wheat', 'white',\n                    'whitesmoke', 'yellow', 'yellowgreen'\n                ],\n\n                regex: {\n                    hex: [\n                        /(^#[0-9A-F]{6}$)|(^#[0-9A-F]{3}$)/i\n                    ],\n                    hsl: [\n                        /^hsl\\((\\s*(-?\\d+)\\s*,)(\\s*(\\b(0?\\d{1,2}|100)\\b%)\\s*,)(\\s*(\\b(0?\\d{1,2}|100)\\b%)\\s*)\\)$/\n                    ],\n                    hsla: [\n                        /^hsla\\((\\s*(-?\\d+)\\s*,)(\\s*(\\b(0?\\d{1,2}|100)\\b%)\\s*,){2}(\\s*(0?(\\.\\d+)?|1(\\.0+)?)\\s*)\\)$/\n                    ],\n                    rgb: [\n                        /^rgb\\((\\s*(\\b([01]?\\d{1,2}|2[0-4]\\d|25[0-5])\\b)\\s*,){2}(\\s*(\\b([01]?\\d{1,2}|2[0-4]\\d|25[0-5])\\b)\\s*)\\)$/,\n                        /^rgb\\((\\s*(\\b(0?\\d{1,2}|100)\\b%)\\s*,){2}(\\s*(\\b(0?\\d{1,2}|100)\\b%)\\s*)\\)$/\n                    ],\n                    rgba: [\n                        /^rgba\\((\\s*(\\b([01]?\\d{1,2}|2[0-4]\\d|25[0-5])\\b)\\s*,){3}(\\s*(0?(\\.\\d+)?|1(\\.0+)?)\\s*)\\)$/,\n                        /^rgba\\((\\s*(\\b(0?\\d{1,2}|100)\\b%)\\s*,){3}(\\s*(0?(\\.\\d+)?|1(\\.0+)?)\\s*)\\)$/\n                    ]\n                },\n\n                validate: function (val, types) {\n                    var keywords = rules.colour.keywords,\n                        expr = rules.colour.regex,\n                        thisType,\n                        i,\n                        j;\n\n                    // if using a colour input, test against the hex regex straight away\n                    if ($(this).attr('type') === 'color') {\n                        return expr.hex[0].test(val);\n                    }\n\n                    // default to allow all types\n                    types = types || ['keywords', 'hex', 'hsl', 'hsla', 'rgb', 'rgba'];\n\n                    // if types passed in as a string, replace the possible separators and make array\n                    if (typeof types === 'string') {\n                        types = types.replace(rules.colour.separators, ' ').split(' ');\n                    }\n\n                    // keywords check\n                    if ($.inArray('keywords', types) > -1 && $.inArray(val, keywords) > -1) {\n                        return true;\n                    }\n\n                    // cycle through types\n                    for (i = 0; i < types.length; i += 1) {\n                        thisType = types[i];\n                        // if we have expressions for that type, check them\n                        if (typeof expr[thisType] === 'object') {\n                            for (j = 0; j < expr[thisType].length; j += 1) {\n                                // if it passes, return true immediately\n                                if (expr[thisType][j].test(val)) {\n                                    return true;\n                                }\n                            }\n                        }\n                    }\n\n                    // return false by default\n                    return false;\n                }\n            },\n\n            /*\n             * add a test to the internal rules\n             * @param name {string}\n             * @param test {function}\n             */\n            addTest: function (name, test) {\n                if (typeof name !== 'string' || typeof test !== 'function') {\n                    throw new Error('A string and a function are required to add a test');\n                }\n\n                // only store rules as lowercase for consistency, and to protect methods\n                name = name.toLowerCase();\n\n                // do not override any existing rules\n                if (typeof rules[name] === 'undefined') {\n                    rules[name] = {\n                        validate: function (val, param) {\n                            return test.call(this, val, param);\n                        }\n                    };\n                }\n            },\n\n            /*\n             * set rule aliases and add rules to application object to be exposed\n             */\n            setAliases: function () {\n                var i,\n                    k,\n                    thisAlias,\n                    aliases = [\n                        'required', 'alpha', 'alphanumeric', 'email', 'equalto', 'format', 'pattern', 'number', 'numeric', 'integer',\n                        'digits', 'ip', 'ipaddress', 'checked', 'unchecked', 'date', 'url', 'creditcard', 'color', 'colour'\n                    ];\n\n                // set specific aliases\n                rules.ip = rules.ipaddress;\n                rules.color = rules.colour;\n                rules.numeric = rules.number;\n                rules.format = rules.pattern = rules.regexp = rules.regex;\n                rules.equals = rules.equalto = rules.matches = rules.match;\n\n                // create is- aliases\n                for (i = 0; i < aliases.length; i += 1) {\n                    thisAlias = aliases[i];\n                    rules['is' + thisAlias] = rules[thisAlias];\n                }\n            },\n\n            /*\n             * generate a space delimited string of all rules\n             */\n            setErrorClassString: function () {\n                var i,\n                    r = ['validation-failed'];\n\n                for (i in rules) {\n                    if (rules.hasOwnProperty(i) && typeof rules[i] === 'object') {\n                        r.push('validation-failed-' + i);\n                    }\n                }\n\n                rules.errorClassString = r.join(' ');\n            }\n        };\n\n    /*\n     * main application methods\n     */\n    app = {\n\n        /*\n         * get data from all inputs in the form\n         * @param $form {jQuery object}\n         * @param attribute {string} optional: attribute to use - defaults to name\n         * @return {object}\n         */\n        getFormData: function ($form, attribute) {\n            // handle defaults\n            $form = $form || $('[data-validation=\"set\"]');\n            attribute = attribute || 'name';\n\n            // default to finding all inouts on the page if no validation has been set\n            if (typeof $form !== 'object' || !$form.length) {\n                $form = $(document);\n            }\n\n            var $inputs = $form.find('input, select, textarea').not('[type=\"submit\"], [type=\"button\"]'),\n                data = {};\n\n            // update data object with input value\n            $inputs.each(function () {\n                var $input = $(this),\n                    attr = $input.attr(attribute),\n                    currentDataPoint = data,\n                    attrArray,\n                    length,\n                    i;\n\n                // do not proceed if attribute does not exist for that element\n                if (typeof attr === 'undefined') {\n                    return;\n                }\n\n                // handle key style naming e.g. primary[secondary][tertiary]\n                if (attr.indexOf('[') > -1 && attr.indexOf(']') > -1) {\n                    attr = attr.split('[').join('.').split(']').join('');\n                }\n\n                // standard case\n                if (attr.indexOf('.') === -1) {\n                    data[attr] = app.element.getValue($input, attribute);\n                    return;\n                }\n\n                // set needed vars for recursive entry creation for chosen attribute\n                attrArray = attr.split('.');\n                length = attrArray.length;\n\n                // set the level in the object that we want to add the new property\n                for (i = 0; i < length - 1; i += 1) {\n                    if (typeof currentDataPoint[attrArray[i]] === 'undefined') {\n                        currentDataPoint[attrArray[i]] = {};\n                    }\n                    currentDataPoint = currentDataPoint[attrArray[i]];\n                }\n\n                // use length - 1 so the final entry in the array is used as the property name\n                currentDataPoint[attrArray[length - 1]] = app.element.getValue($input, attribute);\n            });\n\n            return data;\n        },\n\n        /*\n         * element handling\n         */\n        element: {\n\n            /*\n             * check if element is checkbox or radio type\n             * @param elem {HTMLElement|jQuery object}\n             */\n            isCheckable: function (elem) {\n                return (/radio|checkbox/i).test($(elem).attr('type'));\n            },\n\n            /*\n             * get all elements with matching attribute value\n             * @param $el {jQuery object}\n             * @param attribute {string} optional: defaults to 'name'\n             * @return {jQuery object}: returns $el if none were founding with matching attribute value\n             */\n            getByAttribute: function ($el, attribute) {\n                attribute = attribute || 'name';\n                var $result = $('[' + attribute + '=\"' + $el.attr(attribute) + '\"]');\n                return $result.length ? $result : $el;\n            },\n\n            /*\n             * get element value\n             * @param $el {jQuery object}\n             * @param attribute {string} optional: attribute to use when selecting multiple elements\n             * @return {string}\n             */\n            getValue: function ($el, attribute) {\n                var result = [];\n                attribute = attribute || 'name';\n\n                // get by name for radio or input types\n                if (app.element.isCheckable($el)) {\n                    $el = app.element.getByAttribute($el, 'name').filter(':checked');\n                }\n\n                // cycle through elements to handle elements with the same name\n                $el.each(function () {\n                    var value = $(this).val();\n                    // check for array e.g. multi-select\n                    if ($.isArray(value)) {\n                        value = value.join(',');\n                    }\n                    result.push(value);\n                });\n\n                // if nothing has been added to the result, set to -1 by default\n                if (result.length === 0) {\n                    result.push(-1);\n                }\n\n                // always return a string - join group values with commas\n                return result.join(',');\n            },\n\n            /*\n             * toggle element classes based on validation, and trigger custom events\n             * @param $el {jQuery object}\n             * @param result {boolean|string}: true if validation has passed, otherwise string indicating failed rule\n             */\n            setClasses: function ($el, result) {\n                // remove all rule classes e.g. failed-number\n                $el.removeClass(rules.errorClassString);\n\n                // toggle remaining needed classes and trigger validation event\n                // use triggerHandler to prevent event bubbling\n                if (result === true) {\n                    $el.triggerHandler('validation.passed');\n                } else {\n                    $el.addClass('validation-failed validation-failed-' + result).triggerHandler('validation.failed', result);\n                }\n            },\n\n            /*\n             * build space delimitted rules string\n             * @param $el {jQuery object}: elements to use when getting validation rules\n             * @return {string}\n             */\n            getRules: function ($el) {\n                var result = [],\n                    stored = {};\n\n                // if only one element, return the validation data from it\n                if ($el.length === 1) {\n                    return $el.data('validation');\n                }\n\n                // if multiple, cycle and add\n                $el.each(function () {\n                    var rules = $(this).data('validation'),\n                        arr = [],\n                        length,\n                        i;\n\n                    // continue if no validation rules are specified on the element\n                    if (typeof rules === 'undefined') {\n                        return;\n                    }\n\n                    arr = rules.split(' ');\n                    length = arr.length;\n\n                    for (i = 0; i < length; i += 1) {\n                        // check that the validation rule has not been added already\n                        if (typeof stored[arr[i]] === 'undefined') {\n                            result.push(arr[i]);\n                            // update stored object to indicate that this rule has been added\n                            stored[arr[i]] = true;\n                        }\n                    }\n                });\n                return result.join(' ');\n            }\n\n        },\n\n        /*\n         * validate storage\n         */\n        validate: {\n\n            /*\n             * required rule stored here to prevent being overidden - called in element context\n             * @param val {string}\n             * @return {boolean}\n             */\n            required: function (val) {\n                var $elem = $(this);\n\n                // handle select - check that a value exists, is not empty, and is not 0 or -1\n                if ($elem[0].nodeName === 'SELECT') {\n                    return val && val.length > 0 && val !== '0' && val !== '-1';\n                }\n\n                // handle radio and checkbox\n                if (app.element.isCheckable($elem)) {\n                    return $elem.filter(':checked').length > 0;\n                }\n\n                // default\n                return val.length > 0;\n            },\n\n            /*\n             * trigger validation on whole form - validates all set form elements\n             * @param e {object}: event object\n             * @return {boolean}: if validation has passed\n             */\n            all: function (e) {\n                var $holder = $(this),\n                    $elems = $holder.find('input[data-validation], select[data-validation], textarea[data-validation]');\n\n                $elems.each(app.validate.element);\n\n                if ($elems.filter('.validation-failed').length) {\n                    $holder.addClass('validation-failed').triggerHandler('validation.failed', app.getFormData($holder));\n                    return false; // return value, and prevents default action if event object is passed in\n                }\n\n                $holder.removeClass('validation-failed').triggerHandler('validation.passed', app.getFormData($holder));\n                return true;\n            },\n\n            /*\n             * cycle through all rules for an element\n             * @param $el {jQuery object}\n             * @param rulesArr {array}: array of rule strings\n             * @aram value {string}: element value\n             * @return {boolean|string}: a string containing the failed rule, or true if validation passed\n             */\n            rules: function ($el, rulesArr, value) {\n                var length = rulesArr.length,\n                    result = true,\n                    currentRule,\n                    funcToCall,\n                    splitRule,\n                    param,\n                    i;\n\n                // cycle through remaining rules\n                for (i = 0; i < length; i += 1) {\n                    currentRule = rulesArr[i];\n                    param = undefined;\n\n                    // extract any provided param - use shift and join to handle multiple colons in value\n                    if (currentRule.indexOf(':') > -1) {\n                        splitRule = currentRule.split(':');\n                        currentRule = splitRule.shift();\n                        param = splitRule.join(':');\n                    }\n\n                    // all validation rules are stored as lower case\n                    currentRule = currentRule.toLowerCase();\n\n                    // grab rule validate method\n                    funcToCall = typeof rules[currentRule] === 'object'\n                        ? rules[currentRule].validate\n                        : '';\n\n                    // ignore empty string, required (handled elsewhere), and anything not a function\n                    if (currentRule !== 'required' && currentRule !== 'isrequired' && currentRule !== '' && typeof funcToCall === 'function') {\n                        if (funcToCall.call($el, value, param) === false) {\n                            result = currentRule;\n                            break;\n                        }\n                    }\n                }\n\n                return result;\n            },\n\n            /*\n             * validate an individual element\n             * @param e {object}: event object\n             * @return {string|boolean}: returns the first failed rule, or true if validation has passed\n             */\n            element: function (e) {\n                var $el = $(this),\n                    value = app.element.getValue($el),\n                    result = true,\n                    rulesString,\n                    $tempEl;\n\n                // handle radio and input types - select all elements with that name\n                if (app.element.isCheckable($el)) {\n                    $el = app.element.getByAttribute($el, 'name');\n                }\n\n                // fetch rules once we have all the necessary elements\n                rulesString = app.element.getRules($el);\n\n                // use required function to check if value is empty\n                if (!app.validate.required.call($el, value)) {\n                    // return 'required' or 'isrequired' if in validation rules, otherwise pass\n                    result = (' ' + rulesString.toLowerCase() + ' ').indexOf(' required ') > -1 ? 'required' : (' ' + rulesString.toLowerCase() + ' ').indexOf(' isrequired ') > -1 ? 'isrequired' : true;\n                } else {\n                    // if value is not empty, cycle through any remaining rules\n                    result = app.validate.rules($el, rulesString.split(' '), value);\n                }\n\n                app.element.setClasses($el, result);\n                return result;\n            },\n\n            /*\n             * method to trigger validation based on element - used in API\n             * @param value {HTMLElement|jQuery object|string} optional:\n             *      if form element(s) (input, select, textarea), will validate those elements\n             *      if any other element, will validate all form elements inside\n             *      if given a string, will validate that string against the rules in rules param\n             * @param tests {string|array} optional: set of rules to run against the value - defaults to 'required'\n             *      if a string, must be space delimited e.g. 'required alpha minlength:5' or ['required', 'alpha', 'minlength:5']\n             *      is not used if the value param is not a string\n             * @return {boolean|string}: returns true if all validation has passed (or there were no elements to validate)\n             *      validation assumed to have passed if testing against non-existent rules\n             *      if checking a string and the validation does not pass, will return the first rule that fails\n             */\n            handle: function (value, tests) {\n                var $elems;\n\n                // handle value variant\n                if (typeof value === 'string') {\n                    // if no rules passed in, assume required only\n                    if (typeof tests === 'undefined' || tests === null || tests === '') {\n                        tests = 'required';\n                    }\n\n                    // turn into array\n                    if (typeof tests === 'string') {\n                        tests = tests.split(' ');\n                    }\n\n                    // context\n                    return app.validate.rules({}, tests, value);\n                } else {\n                    // validate all set forms by default\n                    if (!($elems = $(value || '[data-validation=\"set\"]')).length) {\n                        return true; // if no elements exist, return true\n                    }\n\n                    // generate string of error classes to remove\n                    rules.setErrorClassString();\n\n                    // validate\n                    return (/input|select|textarea/i).test($elems[0].nodeName)\n                        ? !$elems.each(app.validate.element).filter('validation-failed').length\n                        : app.validate.all.call($elems);\n                }\n            }\n        },\n\n        /*\n         * given holder element as context\n         */\n        prep: function () {\n            // reset the data-validation attribute so that events are not bound on subsequent init calls\n            var $form = $(this).attr('data-validation', 'set');\n\n            // bind full submit handling to the form submit event if using a normal form\n            if (this.nodeName === 'FORM') {\n                $form.on('submit', function (e) {\n                    return app.validate.handle(this);\n                });\n            }\n\n            // bind to validation-trigger elements - use the closest form to allow nested forms\n            $form.on('click', '.validation-trigger', function (e) {\n                app.validate.handle($(this).closest('[data-validation=\"set\"]'));\n            });\n\n            // bind individual input change events\n            $form.on('change', 'input, select, textarea', function (e) {\n                // check if the form itself has a parent form as we only want to fire the delegated event once\n                var prevent = $form.parent().closest('[data-validation=\"set\"]').length ||\n                    // if radio or checkbox, check if any in the same group have a data-validation attribute\n                    // otherwise, just check if validation attribute exists on the element\n                    (app.element.isCheckable($(this))\n                        ? !app.element.getByAttribute($(this), 'name').filter('[data-validation]').length\n                        : typeof $(this).data('validation') === 'undefined');\n\n                if (!prevent) {\n                    app.validate.handle(this);\n                }\n            });\n        },\n\n        /*\n         * primary setup method\n         */\n        init: function () {\n            $('[data-validation=\"true\"]').each(app.prep);\n        }\n    };\n\n    // set rules aliases\n    rules.setAliases();\n\n    // expose\n    return {\n        init: app.init,\n        addTest: rules.addTest,\n        getFormData: app.getFormData,\n        validate: function (value, rules) {\n            return app.validate.handle(value, rules);\n        }\n    };\n\n}));\n"],"sourceRoot":"/source/"}